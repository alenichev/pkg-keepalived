commit 0131f241cd48e518942c59ac4301090c27f37024
Author: Vincent Bernat <bernat@luffy.cx>
Date:   Mon Aug 23 13:32:52 2010 +0200

    check: Read-only SNMP support
    
    Most internal values can be queried using SNMP. The main exception is
    the ability to query checkers which is not present.

diff --git a/doc/KEEPALIVED-MIB b/doc/KEEPALIVED-MIB
index 7a04ac4..c53a54c 100644
--- a/doc/KEEPALIVED-MIB
+++ b/doc/KEEPALIVED-MIB
@@ -1044,6 +1044,583 @@ vrrpScriptFall OBJECT-TYPE
     ::= { vrrpScriptEntry 8 }
 
 -- ----------------------------------------------------------------------
+-- Healthchecker part
+-- ----------------------------------------------------------------------
+
+-- Virtual server group
+
+virtualServerGroupTable OBJECT-TYPE
+    SYNTAX SEQUENCE OF VirtualServerGroupEntry
+    MAX-ACCESS not-accessible
+    STATUS current
+    DESCRIPTION
+	"Table of virtual server groups."
+    ::= { check 1 }
+
+virtualServerGroupEntry OBJECT-TYPE
+    SYNTAX VirtualServerGroupEntry
+    MAX-ACCESS not-accessible
+    STATUS current
+    DESCRIPTION
+	"Information describing a virtual server group."
+    INDEX { virtualServerGroupIndex }
+    ::= { virtualServerGroupTable 1 }
+
+VirtualServerGroupEntry ::= SEQUENCE {
+	virtualServerGroupIndex Integer32,
+	virtualServerGroupName DisplayString
+}
+
+virtualServerGroupIndex OBJECT-TYPE
+    SYNTAX Integer32 (1..2147483647)
+    MAX-ACCESS not-accessible
+    STATUS current
+    DESCRIPTION
+	"Index of the virtual server group."
+    ::= { virtualServerGroupEntry 1 }
+
+virtualServerGroupName OBJECT-TYPE
+    SYNTAX DisplayString
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Name of the virtual server group."
+    ::= { virtualServerGroupEntry 2 }
+
+virtualServerGroupMemberTable OBJECT-TYPE
+    SYNTAX SEQUENCE OF VirtualServerGroupMemberEntry
+    MAX-ACCESS not-accessible
+    STATUS current
+    DESCRIPTION
+	"Table of members of a virtual server group."
+    ::= { check 2 }
+
+virtualServerGroupMemberEntry OBJECT-TYPE
+    SYNTAX VirtualServerGroupMemberEntry
+    MAX-ACCESS not-accessible
+    STATUS current
+    DESCRIPTION
+	"Description of a member of a virtual server group."
+    INDEX { virtualServerGroupIndex, virtualServerGroupMemberIndex }
+    ::= { virtualServerGroupMemberTable 1 }
+
+VirtualServerGroupMemberEntry ::= SEQUENCE {
+	virtualServerGroupMemberIndex Integer32,
+	virtualServerGroupMemberType INTEGER,
+	virtualServerGroupMemberFwMark Unsigned32,
+	virtualServerGroupMemberAddrType InetAddressType,
+	virtualServerGroupMemberAddress InetAddress,
+	virtualServerGroupMemberAddr1 InetAddress,
+	virtualServerGroupMemberAddr2 InetAddress,
+	virtualServerGroupMemberPort InetPortNumber
+}
+
+virtualServerGroupMemberIndex OBJECT-TYPE
+    SYNTAX Integer32 (1..2147483647)
+    MAX-ACCESS not-accessible
+    STATUS current
+    DESCRIPTION
+	"Index of the member into virtual server group."
+    ::= { virtualServerGroupMemberEntry 1 }
+
+virtualServerGroupMemberType OBJECT-TYPE
+    SYNTAX INTEGER { fwmark(1), ip(2), iprange(3) }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Kind of entry: firewall mark, address with port or range of
+	 addresses with port."
+    ::= { virtualServerGroupMemberEntry 2 }
+
+virtualServerGroupMemberFwMark OBJECT-TYPE
+    SYNTAX Unsigned32
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Firewall mark for this member.
+
+	 If the kind of this member is not fwmark(1), then this entry
+	 should not exist for the current row."
+    ::= { virtualServerGroupMemberEntry 3 }
+
+virtualServerGroupMemberAddrType OBJECT-TYPE
+    SYNTAX InetAddressType
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Type of IP address for this member.
+
+	 If the kind of this member is neither address(2) or range(3),
+	 then this entry should not exist for the current row."
+    ::= { virtualServerGroupMemberEntry 4 }
+
+virtualServerGroupMemberAddress OBJECT-TYPE
+    SYNTAX InetAddress
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"IP address of this member.
+
+	If the kind of this member is not address(2), then this entry
+	should not exist for the current row."
+    ::= { virtualServerGroupMemberEntry 5 }
+
+virtualServerGroupMemberAddr1 OBJECT-TYPE
+    SYNTAX InetAddress
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"First IP address of the range for this member.
+
+	If the kind of this member is not range(3), then this entry
+	should not exist for the current row."
+    ::= { virtualServerGroupMemberEntry 6 }
+
+virtualServerGroupMemberAddr2 OBJECT-TYPE
+    SYNTAX InetAddress
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Second IP address of the range for this member.
+
+	If the kind of this member is not range(3), then this entry
+	should not exist for the current row."
+    ::= { virtualServerGroupMemberEntry 7 }
+
+virtualServerGroupMemberPort OBJECT-TYPE
+    SYNTAX InetPortNumber
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"V port for this member.
+
+	If the kind of this member is neither address(2) nor range(3),
+	then this entry should not exist for the current row."
+    ::= { virtualServerGroupMemberEntry 8 }
+
+-- virtual server
+
+virtualServerTable OBJECT-TYPE
+    SYNTAX SEQUENCE OF VirtualServerEntry
+    MAX-ACCESS not-accessible
+    STATUS current
+    DESCRIPTION
+	"Table of virtual servers."
+    ::= { check 3 }
+
+virtualServerEntry OBJECT-TYPE
+    SYNTAX VirtualServerEntry
+    MAX-ACCESS not-accessible
+    STATUS current
+    DESCRIPTION
+	"Information describing a virtual server."
+    INDEX { virtualServerIndex }
+    ::= { virtualServerTable 1 }
+
+VirtualServerEntry ::= SEQUENCE {
+	virtualServerIndex Integer32,
+	virtualServerType INTEGER,
+	virtualServerNameOfGroup DisplayString,
+	virtualServerFwMark Unsigned32,
+	virtualServerAddrType InetAddressType,
+	virtualServerAddress InetAddress,
+	virtualServerPort InetPortNumber,
+	virtualServerProtocol INTEGER,
+	virtualServerLoadBalancingAlgo INTEGER,
+	virtualServerLoadBalancingKind INTEGER,
+	virtualServerStatus INTEGER,
+	virtualServerVirtualHost DisplayString,
+	virtualServerPersist INTEGER,
+	virtualServerPersistTimeout Unsigned32,
+	virtualServerPersistGranularity InetAddress,
+	virtualServerDelayLoop Unsigned32,
+	virtualServerHaSuspend TruthValue,
+	virtualServerAlpha INTEGER,
+	virtualServerOmega INTEGER,
+	virtualServerRealServersTotal Unsigned32,
+	virtualServerRealServersUp Unsigned32,
+	virtualServerQuorum Unsigned32,
+	virtualServerQuorumStatus INTEGER,
+	virtualServerQuorumUp DisplayString,
+	virtualServerQuorumDown DisplayString,
+	virtualServerHysteresis Unsigned32
+}
+
+virtualServerIndex OBJECT-TYPE
+    SYNTAX Integer32 (1..2147483647)
+    MAX-ACCESS not-accessible
+    STATUS current
+    DESCRIPTION
+	"Index of the virtual server."
+    ::= { virtualServerEntry 1 }
+
+virtualServerType OBJECT-TYPE
+    SYNTAX INTEGER { fwmark(1), ip(2), group(3) }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Type of virtual server. A virtual server can either be
+	defined from a firewall mark, an IP and a port
+	or from a virtual server group."
+    ::= { virtualServerEntry 2 }
+
+virtualServerNameOfGroup OBJECT-TYPE
+    SYNTAX DisplayString
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"If the virtual is defined from a group, this is the name of the group."
+    ::= { virtualServerEntry 3 }
+
+virtualServerFwMark OBJECT-TYPE
+    SYNTAX Unsigned32
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"If the virtual server is defined from a firewall mark, this
+	is the value of the mark. Otherwise, this column should not
+	exist in the current row."
+    ::= { virtualServerEntry 4 }
+
+virtualServerAddrType OBJECT-TYPE
+    SYNTAX InetAddressType
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"If the virtual server is defined from an IP, this
+	is the address family. Otherwise, this column should not
+	exist in the current row."
+    ::= { virtualServerEntry 5 }
+
+virtualServerAddress OBJECT-TYPE
+    SYNTAX InetAddress
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"If the virtual server is defined from an IP address, this
+	is the value of the IP. Otherwise, this column should not
+	exist in the current row."
+    ::= { virtualServerEntry 6 }
+
+virtualServerPort OBJECT-TYPE
+    SYNTAX InetPortNumber
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"If the virtual server is defined from an IP, this is
+	the value of the port to listen for requests. Otherwise, this column
+	should not exist in the current row."
+    ::= { virtualServerEntry 7 }
+
+virtualServerProtocol OBJECT-TYPE
+    SYNTAX INTEGER { tcp(1), udp(2) }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Which transport protocol should be used for this virtual server."
+    ::= { virtualServerEntry 8 }
+
+virtualServerLoadBalancingAlgo OBJECT-TYPE
+    SYNTAX INTEGER {
+    	rr(1),
+	wrr(2),
+	lc(3),
+	wlc(4),
+	lblc(5),
+	lblcr(6),
+	dh(7),
+	sh(8),
+	sed(9),
+	nq(10),
+	unknown(99)
+    }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Which load balancing algorithm (or scheduler) should be used
+	for this virtual server."
+    ::= { virtualServerEntry 9 }
+
+virtualServerLoadBalancingKind OBJECT-TYPE
+    SYNTAX INTEGER { nat(1), dr(2), tun(3) }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Forwarding method to use for this virtual server."
+    ::= { virtualServerEntry 10 }
+
+virtualServerStatus OBJECT-TYPE
+    SYNTAX INTEGER { alive(1), dead(2) }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current status of this virtual server."
+    ::= { virtualServerEntry 11 }
+
+virtualServerVirtualHost OBJECT-TYPE
+    SYNTAX DisplayString
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Virtualhost of this server for HTTP like requests."
+    ::= { virtualServerEntry 12 }
+
+virtualServerPersist OBJECT-TYPE
+    SYNTAX INTEGER { enabled(1), disabled(2) }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Is the virtual service persistence enabled?"
+    ::= { virtualServerEntry 13 }
+
+virtualServerPersistTimeout OBJECT-TYPE
+    SYNTAX Unsigned32
+    UNITS "seconds"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"If this virtual service is persistence, what is the timeout."
+    ::= { virtualServerEntry 14 }
+
+virtualServerPersistGranularity OBJECT-TYPE
+    SYNTAX InetAddress
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Netmask specifying the granularity of the persistence mechanism."
+    ::= { virtualServerEntry 15 }
+
+virtualServerDelayLoop OBJECT-TYPE
+    SYNTAX Unsigned32
+    UNITS "seconds"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Delay in seconds between two checks."
+    ::= { virtualServerEntry 16 }
+
+virtualServerHaSuspend OBJECT-TYPE
+    SYNTAX TruthValue
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"If set to true(1), checks will be suspended if the IP of the
+	virtual server is currently not set."
+    ::= { virtualServerEntry 17 }
+
+virtualServerAlpha OBJECT-TYPE
+    SYNTAX INTEGER { enabled(1), disabled(2) }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Is alpha mode enabled?"
+    ::= { virtualServerEntry 18 }
+
+virtualServerOmega OBJECT-TYPE
+    SYNTAX INTEGER { enabled(1), disabled(2) }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Is omega mode enabled?"
+    ::= { virtualServerEntry 19 }
+
+virtualServerRealServersTotal OBJECT-TYPE
+    SYNTAX Unsigned32
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Total number of real servers for this virtual server."
+    ::= { virtualServerEntry 20 }
+
+virtualServerRealServersUp OBJECT-TYPE
+    SYNTAX Unsigned32
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Real servers actually up for this virtual server."
+    ::= { virtualServerEntry 21 }
+
+virtualServerQuorum OBJECT-TYPE
+    SYNTAX Unsigned32
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Quorum to get amond real servers to consider this virtual server up."
+    ::= { virtualServerEntry 22 }
+
+virtualServerQuorumStatus OBJECT-TYPE
+    SYNTAX INTEGER { met(1), notMet(2) }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current status of the quorum for this virtual server."
+    ::= { virtualServerEntry 23 }
+
+virtualServerQuorumUp OBJECT-TYPE
+    SYNTAX DisplayString
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Command to execute when the quorum is met."
+    ::= { virtualServerEntry 24 }
+
+virtualServerQuorumDown OBJECT-TYPE
+    SYNTAX DisplayString
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Command to execute when the quorum is not met."
+    ::= { virtualServerEntry 25 }
+
+virtualServerHysteresis OBJECT-TYPE
+    SYNTAX Unsigned32
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Hysteresis with respect to quorum count."
+    ::= { virtualServerEntry 26 }
+
+-- real servers
+
+realServerTable OBJECT-TYPE
+    SYNTAX SEQUENCE OF RealServerEntry
+    MAX-ACCESS not-accessible
+    STATUS current
+    DESCRIPTION
+	"Table of real servers. This includes regular real servers and sorry servers."
+    ::= { check 4 }
+
+realServerEntry OBJECT-TYPE
+    SYNTAX RealServerEntry
+    MAX-ACCESS not-accessible
+    STATUS current
+    DESCRIPTION
+	"Information describing a real server."
+    INDEX { virtualServerIndex, realServerIndex }
+    ::= { realServerTable 1 }
+
+RealServerEntry ::= SEQUENCE {
+	realServerIndex Integer32,
+	realServerType INTEGER,
+	realServerAddrType InetAddressType,
+	realServerAddress InetAddress,
+	realServerPort InetPortNumber,
+	realServerStatus INTEGER,
+	realServerWeight Integer32,
+	realServerUpperConnectionLimit Unsigned32,
+	realServerLowerConnectionLimit Unsigned32,
+	realServerActionWhenDown INTEGER,
+	realServerNotifyUp DisplayString,
+	realServerNotifyDown DisplayString,
+	realServerFailedChecks Unsigned32
+}
+
+realServerIndex OBJECT-TYPE
+    SYNTAX Integer32 (1..2147483647)
+    MAX-ACCESS not-accessible
+    STATUS current
+    DESCRIPTION
+	"Index of the real server."
+    ::= { realServerEntry 1 }
+
+realServerType OBJECT-TYPE
+    SYNTAX INTEGER { regular(1), sorry(2) }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Type of real server: either a regular real server or a sorry server."
+    ::= { realServerEntry 2 }
+
+realServerAddrType OBJECT-TYPE
+    SYNTAX InetAddressType
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Address family for this real server."
+    ::= { realServerEntry 3 }
+
+realServerAddress OBJECT-TYPE
+    SYNTAX InetAddress
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"IP address of this real server."
+    ::= { realServerEntry 4 }
+
+realServerPort OBJECT-TYPE
+    SYNTAX InetPortNumber
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Port of the service."
+    ::= { realServerEntry 5 }
+
+realServerStatus OBJECT-TYPE
+    SYNTAX INTEGER { alive(1), dead(2) }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Status of this real server."
+    ::= { realServerEntry 6 }
+
+realServerWeight OBJECT-TYPE
+    SYNTAX Integer32
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Weight of this real server."
+    ::= { realServerEntry 7 }
+
+realServerUpperConnectionLimit OBJECT-TYPE
+    SYNTAX Unsigned32
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Maximum number of connections for this real server."
+    ::= { realServerEntry 8 }
+
+realServerLowerConnectionLimit OBJECT-TYPE
+    SYNTAX Unsigned32
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Minimum number of connections for this real server."
+    ::= { realServerEntry 9 }
+
+realServerActionWhenDown OBJECT-TYPE
+    SYNTAX INTEGER { remove(1), inhibit(2) }
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"What action is performed when this server is down. Its weight
+	can be set to 0 (inhibit) or it can be removed from the pool."
+    ::= { realServerEntry 10 }
+
+realServerNotifyUp OBJECT-TYPE
+    SYNTAX DisplayString
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Command to execute when this server becomes alive."
+    ::= { realServerEntry 11 }
+
+realServerNotifyDown OBJECT-TYPE
+    SYNTAX DisplayString
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Command to execute when this server becomes dead."
+    ::= { realServerEntry 12 }
+
+realServerFailedChecks OBJECT-TYPE
+    SYNTAX Unsigned32
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"How many failed checks for this real server."
+    ::= { realServerEntry 13 }
+
+-- ----------------------------------------------------------------------
 -- Conformance
 -- ----------------------------------------------------------------------
 
@@ -1072,6 +1649,18 @@ vrrpCompliances MODULE-COMPLIANCE
     }
     ::= { compliances 2 }
 
+checkCompliances MODULE-COMPLIANCE
+    STATUS current
+    DESCRIPTION
+	"The check compliance statement"
+    MODULE -- this module
+    MANDATORY-GROUPS {
+	virtualServerGroupGroup,
+	virtualServerGroup,
+	realServerGroup
+    }
+    ::= { compliances 3 }
+
 globalGroup OBJECT-GROUP
     OBJECTS {
     	version,
@@ -1180,4 +1769,73 @@ vrrpScriptGroup OBJECT-GROUP
 	"Conformance group for VRRP scripts."
     ::= { groups 4 }
 
+virtualServerGroupGroup OBJECT-GROUP
+    OBJECTS {
+	virtualServerGroupName,
+	virtualServerGroupMemberType,
+	virtualServerGroupMemberFwMark,
+	virtualServerGroupMemberAddrType,
+	virtualServerGroupMemberAddress,
+	virtualServerGroupMemberAddr1,
+	virtualServerGroupMemberAddr2,
+	virtualServerGroupMemberPort
+	}
+    STATUS current
+    DESCRIPTION
+	"Conformance group for virtual server groups."
+    ::= { groups 5 }
+
+virtualServerGroup OBJECT-GROUP
+    OBJECTS {
+	virtualServerType,
+	virtualServerNameOfGroup,
+	virtualServerFwMark,
+	virtualServerAddrType,
+	virtualServerAddress,
+	virtualServerPort,
+	virtualServerProtocol,
+	virtualServerLoadBalancingAlgo,
+	virtualServerLoadBalancingKind,
+	virtualServerStatus,
+	virtualServerVirtualHost,
+	virtualServerPersist,
+	virtualServerPersistTimeout,
+	virtualServerPersistGranularity,
+	virtualServerDelayLoop,
+	virtualServerHaSuspend,
+	virtualServerAlpha,
+	virtualServerOmega,
+	virtualServerRealServersTotal,
+	virtualServerRealServersUp,
+	virtualServerQuorum,
+	virtualServerQuorumStatus,
+	virtualServerQuorumUp,
+	virtualServerQuorumDown,
+	virtualServerHysteresis
+	}
+    STATUS current
+    DESCRIPTION
+	"Conformance group for virtual servers."
+    ::= { groups 6 }
+
+realServerGroup OBJECT-GROUP
+    OBJECTS {
+	realServerType,
+	realServerAddrType,
+	realServerAddress,
+	realServerPort,
+	realServerStatus,
+	realServerWeight,
+	realServerUpperConnectionLimit,
+	realServerLowerConnectionLimit,
+	realServerActionWhenDown,
+	realServerNotifyUp,
+	realServerNotifyDown,
+	realServerFailedChecks
+	}
+    STATUS current
+    DESCRIPTION
+	"Conformance group for real servers."
+    ::= { groups 7 }
+
 END
diff --git a/keepalived/check/Makefile.in b/keepalived/check/Makefile.in
index 2b0d820..c3d4a36 100644
--- a/keepalived/check/Makefile.in
+++ b/keepalived/check/Makefile.in
@@ -4,17 +4,22 @@
 #
 # Copyright (C) 2001-2011 Alexandre Cassen, <acassen@linux-vs.org>
 
+SNMP_FLAG = @SNMP_SUPPORT@
+
 KERNEL   = @KERN@
 CC	 = @CC@
 INCLUDES = -I../include -I../../lib
 CFLAGS	 = @CFLAGS@ @CPPFLAGS@ $(INCLUDES) \
 	   -Wall -Wunused -Wstrict-prototypes
-DEFS	 = -D$(KERNEL) -D@IPVS_SUPPORT@ -D@IPVS_SYNCD@ -D@VRRP_SUPPORT@ @DFLAGS@
+DEFS	 = -D$(KERNEL) -D@IPVS_SUPPORT@ -D@IPVS_SYNCD@ -D@VRRP_SUPPORT@ -D@SNMP_SUPPORT@ @DFLAGS@
 COMPILE	 = $(CC) $(CFLAGS) $(DEFS)
 
 OBJS = 	check_daemon.o check_data.o check_parser.o \
 	check_api.o check_tcp.o check_http.o check_ssl.o \
 	check_smtp.o check_misc.o ipwrapper.o ipvswrapper.o
+ifeq ($(SNMP_FLAG),_WITH_SNMP_)
+  OBJS += check_snmp.o
+endif
 
 HEADERS = $(OBJS:.o=.h)
 
@@ -34,7 +39,7 @@ check_daemon.o: check_daemon.c ../include/check_daemon.h \
   ../include/global_data.h ../include/ipwrapper.h ../include/ipwrapper.h \
   ../include/pidfile.h ../include/daemon.h ../../lib/list.h ../../lib/memory.h \
   ../../lib/parser.h ../../lib/signals.h ../include/vrrp_netlink.h \
-  ../include/vrrp_if.h
+  ../include/vrrp_if.h ../include/snmp.h ../include/check_snmp.h
 check_data.o: check_data.c ../include/check_data.h \
   ../include/check_api.h ../../lib/memory.h ../../lib/utils.h
 check_parser.o: check_parser.c ../include/check_parser.h \
@@ -63,3 +68,5 @@ ipwrapper.o: ipwrapper.c ../include/ipwrapper.h ../../lib/memory.h \
   ../../lib/utils.h ../../lib/notify.h
 ipvswrapper.o: ipvswrapper.c ../include/ipvswrapper.h ../../lib/utils.h \
   ../../lib/memory.h
+check_snmp.o: check_snmp.c ../include/check_snmp.h ../include/check_data.h \
+  ../../lib/list.h
diff --git a/keepalived/check/check_daemon.c b/keepalived/check/check_daemon.c
index 5821b3d..cff33bd 100644
--- a/keepalived/check/check_daemon.c
+++ b/keepalived/check/check_daemon.c
@@ -40,6 +40,9 @@
 #include "parser.h"
 #include "vrrp_netlink.h"
 #include "vrrp_if.h"
+#ifdef _WITH_SNMP_
+  #include "check_snmp.h"
+#endif
 
 extern char *checkers_pidfile;
 
@@ -55,6 +58,10 @@ stop_check(void)
 	if (!(debug & 16))
 		clear_services();
 	ipvs_stop();
+#ifdef _WITH_SNMP_
+	if (snmp)
+		check_snmp_agent_close();
+#endif
 
 	/* Stop daemon */
 	pidfile_rm(checkers_pidfile);
@@ -89,6 +96,10 @@ start_check(void)
 	init_interface_queue();
 	kernel_netlink_init();
 #endif
+#ifdef _WITH_SNMP_
+	if (!reload && snmp)
+		check_snmp_agent_init();
+#endif
 
 	/* Parse configuration file */
 	data = alloc_global_data();
diff --git a/keepalived/check/check_snmp.c b/keepalived/check/check_snmp.c
new file mode 100644
index 0000000..a21b9bc
--- /dev/null
+++ b/keepalived/check/check_snmp.c
@@ -0,0 +1,730 @@
+/*
+ * Soft:        Keepalived is a failover program for the LVS project
+ *              <www.linuxvirtualserver.org>. It monitor & manipulate
+ *              a loadbalanced server pool using multi-layer checks.
+ *
+ * Part:        SNMP agent
+ *
+ * Version:     $Id$
+ *
+ * Author:      Vincent Bernat <bernat@luffy.cx>
+ *
+ *              This program is distributed in the hope that it will be useful,
+ *              but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *              See the GNU General Public License for more details.
+ *
+ *              This program is free software; you can redistribute it and/or
+ *              modify it under the terms of the GNU General Public License
+ *              as published by the Free Software Foundation; either version
+ *              2 of the License, or (at your option) any later version.
+ *
+ * Copyright (C) 2001-2009 Alexandre Cassen, <acassen@freebox.fr>
+ */
+
+#include "check_snmp.h"
+#include "check_data.h"
+#include "list.h"
+
+/* Magic */
+#define CHECK_SNMP_VSGROUPNAME 1
+#define CHECK_SNMP_VSGROUPMEMBERTYPE 3
+#define CHECK_SNMP_VSGROUPMEMBERFWMARK 4
+#define CHECK_SNMP_VSGROUPMEMBERADDRTYPE 5
+#define CHECK_SNMP_VSGROUPMEMBERADDRESS 6
+#define CHECK_SNMP_VSGROUPMEMBERADDR1 7
+#define CHECK_SNMP_VSGROUPMEMBERADDR2 8
+#define CHECK_SNMP_VSGROUPMEMBERPORT 9
+#define CHECK_SNMP_VSTYPE 10
+#define CHECK_SNMP_VSNAMEGROUP 14
+#define CHECK_SNMP_VSFWMARK 11
+#define CHECK_SNMP_VSADDRTYPE 12
+#define CHECK_SNMP_VSADDRESS 13
+#define CHECK_SNMP_VSPORT 16
+#define CHECK_SNMP_VSPROTOCOL 17
+#define CHECK_SNMP_VSLOADBALANCINGALGO 18
+#define CHECK_SNMP_VSLOADBALANCINGKIND 19
+#define CHECK_SNMP_VSSTATUS 20
+#define CHECK_SNMP_VSVIRTUALHOST 21
+#define CHECK_SNMP_VSPERSIST 22
+#define CHECK_SNMP_VSPERSISTTIMEOUT 23
+#define CHECK_SNMP_VSPERSISTGRANULARITY 24
+#define CHECK_SNMP_VSDELAYLOOP 25
+#define CHECK_SNMP_VSHASUSPEND 26
+#define CHECK_SNMP_VSALPHA 27
+#define CHECK_SNMP_VSOMEGA 28
+#define CHECK_SNMP_VSQUORUM 29
+#define CHECK_SNMP_VSQUORUMSTATUS 30
+#define CHECK_SNMP_VSQUORUMUP 31
+#define CHECK_SNMP_VSQUORUMDOWN 32
+#define CHECK_SNMP_VSHYSTERESIS 33
+#define CHECK_SNMP_VSREALTOTAL 34
+#define CHECK_SNMP_VSREALUP 35
+#define CHECK_SNMP_RSTYPE 36
+#define CHECK_SNMP_RSADDRTYPE 37
+#define CHECK_SNMP_RSADDRESS 38
+#define CHECK_SNMP_RSPORT 39
+#define CHECK_SNMP_RSSTATUS 40
+#define CHECK_SNMP_RSWEIGHT 41
+#define CHECK_SNMP_RSUPPERCONNECTIONLIMIT 42
+#define CHECK_SNMP_RSLOWERCONNECTIONLIMIT 43
+#define CHECK_SNMP_RSACTIONWHENDOWN 44
+#define CHECK_SNMP_RSNOTIFYUP 45
+#define CHECK_SNMP_RSNOTIFYDOWN 46
+#define CHECK_SNMP_RSFAILEDCHECKS 47
+
+#define RETURN_IP46ADDRESS(entity)  do {				\
+		if (entity->addr.ss_family == AF_INET6) {		\
+			struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&entity->addr; \
+			*var_len = 16;					\
+			return (u_char *)&addr6->sin6_addr;		\
+		} else {						\
+			struct sockaddr_in *addr4 = (struct sockaddr_in *)&entity->addr; \
+			*var_len = 4;					\
+			return (u_char *)&addr4->sin_addr;		\
+		}							\
+	} while(0)
+
+static u_char*
+check_snmp_vsgroup(struct variable *vp, oid *name, size_t *length,
+		   int exact, size_t *var_len, WriteMethod **write_method)
+{
+	virtual_server_group *g;
+
+	if ((g = (virtual_server_group *)
+	     snmp_header_list_table(vp, name, length, exact,
+				    var_len, write_method,
+				    check_data->vs_group)) == NULL)
+		return NULL;
+
+	switch (vp->magic) {
+	case CHECK_SNMP_VSGROUPNAME:
+		*var_len = strlen(g->gname);
+		return (u_char *)g->gname;
+	default:
+		break;
+        }
+        return NULL;
+}
+
+static u_char*
+check_snmp_vsgroupmember(struct variable *vp, oid *name, size_t *length,
+			 int exact, size_t *var_len, WriteMethod **write_method)
+{
+	static unsigned long long_ret;
+	static uint32_t ip;
+	static struct in6_addr ip6;
+        oid *target, current[2], best[2];
+        int result, target_len;
+	int curgroup = 0, curentry;
+	element e1, e2;
+	virtual_server_group *group;
+	virtual_server_group_entry *e, *be = NULL;
+#define STATE_VSGM_FWMARK 1
+#define STATE_VSGM_ADDRESS 2
+#define STATE_VSGM_RANGE 3
+#define STATE_VSGM_END 4
+	int state;
+	list l;
+
+
+        if ((result = snmp_oid_compare(name, *length, vp->name, vp->namelen)) < 0) {
+                memcpy(name, vp->name, sizeof(oid) * vp->namelen);
+                *length = vp->namelen;
+        }
+
+	*write_method = 0;
+	*var_len = sizeof(long);
+
+	if (LIST_ISEMPTY(check_data->vs_group))
+		return NULL;
+
+	/* We search the best match: equal if exact, the lower OID in
+	   the set of the OID strictly superior to the target
+	   otherwise. */
+        best[0] = best[1] = MAX_SUBID; /* Our best match */
+        target = &name[vp->namelen];   /* Our target match */
+        target_len = *length - vp->namelen;
+	for (e1 = LIST_HEAD(check_data->vs_group); e1; ELEMENT_NEXT(e1)) {
+		group = ELEMENT_DATA(e1);
+		curgroup++;
+		curentry = 0;
+		if (target_len && (curgroup < target[0]))
+			continue; /* Optimization: cannot be part of our set */
+		if (be)
+			break; /* Optimization: cannot be the lower anymore */
+		state = STATE_VSGM_FWMARK;
+		while (state != STATE_VSGM_END) {
+			switch (state) {
+			case STATE_VSGM_FWMARK:
+				l = group->vfwmark;
+				break;
+			case STATE_VSGM_ADDRESS:
+				l = group->addr_ip;
+				break;
+			case STATE_VSGM_RANGE:
+				l = group->range;
+				break;
+			default:
+				/* Dunno? */
+				return NULL;
+			}
+			state++;
+			if (LIST_ISEMPTY(l))
+				continue;
+			for (e2 = LIST_HEAD(l); e2; ELEMENT_NEXT(e2)) {
+				e = ELEMENT_DATA(e2);
+				curentry++;
+				/* We build our current match */
+				current[0] = curgroup;
+				current[1] = curentry;
+				/* And compare it to our target match */
+				if ((result = snmp_oid_compare(current, 2, target,
+							       target_len)) < 0)
+					continue;
+				if ((result == 0) && !exact)
+					continue;
+				if (result == 0) {
+					/* Got an exact match and asked for it */
+					be = e;
+					goto vsgmember_found;
+				}
+				if (snmp_oid_compare(current, 2, best, 2) < 0) {
+					/* This is our best match */
+					memcpy(best, current, sizeof(oid) * 2);
+					be = e;
+					goto vsgmember_be_found;
+				}
+			}
+		}
+	}
+	if (be == NULL)
+		/* No best match */
+		return NULL;
+	if (exact)
+		/* No exact match */
+		return NULL;
+ vsgmember_be_found:
+	/* Let's use our best match */
+        memcpy(target, best, sizeof(oid) * 2);
+        *length = vp->namelen + 2;
+ vsgmember_found:
+	switch (vp->magic) {
+	case CHECK_SNMP_VSGROUPMEMBERTYPE:
+		if (be->vfwmark)
+			long_ret = 1;
+		else if (be->range)
+			long_ret = 3;
+		else
+			long_ret = 2;
+		return (u_char *)&long_ret;
+	case CHECK_SNMP_VSGROUPMEMBERFWMARK:
+		if (!be->vfwmark) break;
+		long_ret = be->vfwmark;
+		return (u_char *)&long_ret;
+	case CHECK_SNMP_VSGROUPMEMBERADDRTYPE:
+		if (be->vfwmark) break;
+		long_ret = (be->addr.ss_family == AF_INET6) ? 2:1;
+		return (u_char *)&long_ret;
+	case CHECK_SNMP_VSGROUPMEMBERADDRESS:
+		if (be->vfwmark || be->range) break;
+		RETURN_IP46ADDRESS(be);
+		break;
+	case CHECK_SNMP_VSGROUPMEMBERADDR1:
+		if (!be->range) break;
+		RETURN_IP46ADDRESS(be);
+		break;
+	case CHECK_SNMP_VSGROUPMEMBERADDR2:
+		if (!be->range) break;
+		if (be->addr.ss_family == AF_INET6) {
+			struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&be->addr;
+			*var_len = 16;
+			memcpy(&ip6, &addr6->sin6_addr, sizeof(ip6));
+			ip6.s6_addr32[3] &= htonl(0xFFFFFF00);
+			ip6.s6_addr32[3] += htonl(be->range);
+			return (u_char *)&ip6;
+		} else {
+			struct sockaddr_in *addr4 = (struct sockaddr_in *)&be->addr;
+			*var_len = 4;
+			ip = (*(u_int32_t *)&addr4->sin_addr) & htonl(0xFFFFFF00);
+			ip += htonl(be->range);
+			return (u_char *)&ip;
+		}
+		break;
+	case CHECK_SNMP_VSGROUPMEMBERPORT:
+		if (be->vfwmark) break;
+		long_ret = htons(inet_sockaddrport(&be->addr));
+		return (u_char *)&long_ret;
+	default:
+		return NULL;
+	}
+	/* If we are here, we asked for a non existent data. Try the
+	   next one. */
+	if (!exact && (name[*length-1] < MAX_SUBID))
+		return check_snmp_vsgroupmember(vp, name, length,
+						exact, var_len, write_method);
+        return NULL;
+}
+
+static u_char*
+check_snmp_virtualserver(struct variable *vp, oid *name, size_t *length,
+			 int exact, size_t *var_len, WriteMethod **write_method)
+{
+	static unsigned long long_ret;
+	virtual_server *v;
+	element e;
+
+	if ((v = (virtual_server *)
+	     snmp_header_list_table(vp, name, length, exact,
+				    var_len, write_method,
+				    check_data->vs)) == NULL)
+		return NULL;
+
+	switch (vp->magic) {
+	case CHECK_SNMP_VSTYPE:
+		if (v->vsgname)
+			long_ret = 3;
+		else if (v->vfwmark)
+			long_ret = 1;
+		else
+			long_ret = 2;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSNAMEGROUP:
+		if (!v->vsgname) break;
+		*var_len = strlen(v->vsgname);
+		return (u_char*)v->vsgname;
+	case CHECK_SNMP_VSFWMARK:
+		if (!v->vfwmark) break;
+		long_ret = v->vfwmark;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSADDRTYPE:
+		if (v->vfwmark || v->vsgname) break;
+		long_ret = (v->addr.ss_family == AF_INET6) ? 2:1;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSADDRESS:
+		if (v->vfwmark || v->vsgname) break;
+		RETURN_IP46ADDRESS(v);
+		break;
+	case CHECK_SNMP_VSPORT:
+		if (v->vfwmark || v->vsgname) break;
+		long_ret = htons(inet_sockaddrport(&v->addr));
+		return (u_char *)&long_ret;
+	case CHECK_SNMP_VSPROTOCOL:
+		long_ret = (v->service_type == IPPROTO_TCP)?1:2;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSLOADBALANCINGALGO:
+		if (strncmp(v->sched, "rr", SCHED_MAX_LENGTH) == 0)
+			long_ret = 1;
+		else if (strncmp(v->sched, "wrr", SCHED_MAX_LENGTH) == 0)
+			long_ret = 2;
+		else if (strncmp(v->sched, "lc", SCHED_MAX_LENGTH) == 0)
+			long_ret = 3;
+		else if (strncmp(v->sched, "wlc", SCHED_MAX_LENGTH) == 0)
+			long_ret = 4;
+		else if (strncmp(v->sched, "lblc", SCHED_MAX_LENGTH) == 0)
+			long_ret = 5;
+		else if (strncmp(v->sched, "lblcr", SCHED_MAX_LENGTH) == 0)
+			long_ret = 6;
+		else if (strncmp(v->sched, "dh", SCHED_MAX_LENGTH) == 0)
+			long_ret = 7;
+		else if (strncmp(v->sched, "sh", SCHED_MAX_LENGTH) == 0)
+			long_ret = 8;
+		else if (strncmp(v->sched, "sed", SCHED_MAX_LENGTH) == 0)
+			long_ret = 9;
+		else if (strncmp(v->sched, "nq", SCHED_MAX_LENGTH) == 0)
+			long_ret = 10;
+		else long_ret = 99;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSLOADBALANCINGKIND:
+		long_ret = 0;
+		switch (v->loadbalancing_kind) {
+#ifdef _WITH_LVS_
+#ifdef _KRNL_2_2_
+		case 0:
+			long_ret = 1;
+			break;
+		case IP_MASQ_F_VS_DROUTE:
+			long_ret = 2;
+			break;
+		case IP_MASQ_F_VS_TUNNEL:
+			long_ret = 3;
+			break;
+#else
+		case IP_VS_CONN_F_MASQ:
+			long_ret = 1;
+			break;
+		case IP_VS_CONN_F_DROUTE:
+			long_ret = 2;
+			break;
+		case IP_VS_CONN_F_TUNNEL:
+			long_ret = 3;
+			break;
+#endif
+#endif
+		}
+		if (!long_ret) break;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSSTATUS:
+		long_ret = v->alive?1:2;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSVIRTUALHOST:
+		if (!v->virtualhost) break;
+		*var_len = strlen(v->virtualhost);
+		return (u_char*)v->virtualhost;
+	case CHECK_SNMP_VSPERSIST:
+		long_ret = (atol(v->timeout_persistence) > 0)?1:2;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSPERSISTTIMEOUT:
+		if (atol(v->timeout_persistence) <= 0) break;
+		long_ret = atol(v->timeout_persistence);
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSPERSISTGRANULARITY:
+		if (atol(v->timeout_persistence) <= 0) break;
+		if (!v->granularity_persistence) break;
+		*var_len = 4;
+		return (u_char*)&v->granularity_persistence;
+	case CHECK_SNMP_VSDELAYLOOP:
+		if (v->delay_loop >= TIMER_MAX_SEC)
+			long_ret = v->delay_loop/TIMER_HZ;
+		else
+			long_ret = v->delay_loop;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSHASUSPEND:
+		long_ret = v->ha_suspend?1:2;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSALPHA:
+		long_ret = v->alpha?1:2;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSOMEGA:
+		long_ret = v->omega?1:2;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSQUORUM:
+		long_ret = v->quorum;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSQUORUMSTATUS:
+		long_ret = v->quorum_state?1:2;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSQUORUMUP:
+		if (!v->quorum_up) break;
+		*var_len = strlen(v->quorum_up);
+		return (u_char*)v->quorum_up;
+	case CHECK_SNMP_VSQUORUMDOWN:
+		if (!v->quorum_down) break;
+		*var_len = strlen(v->quorum_down);
+		return (u_char*)v->quorum_down;
+	case CHECK_SNMP_VSHYSTERESIS:
+		long_ret = v->hysteresis;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSREALTOTAL:
+		if (LIST_ISEMPTY(v->rs))
+			long_ret = 0;
+		else
+			long_ret = LIST_SIZE(v->rs);
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSREALUP:
+		long_ret = 0;
+		if (!LIST_ISEMPTY(v->rs))
+			for (e = LIST_HEAD(v->rs); e; ELEMENT_NEXT(e))
+				if (((real_server *)ELEMENT_DATA(e))->alive)
+					long_ret++;
+		return (u_char*)&long_ret;
+	default:
+		return NULL;
+        }
+	if (!exact && (name[*length-1] < MAX_SUBID))
+		return check_snmp_virtualserver(vp, name, length,
+						exact, var_len, write_method);
+        return NULL;
+}
+
+static u_char*
+check_snmp_realserver(struct variable *vp, oid *name, size_t *length,
+		      int exact, size_t *var_len, WriteMethod **write_method)
+{
+	static unsigned long long_ret;
+        oid *target, current[2], best[2];
+        int result, target_len;
+	int curvirtual = 0, curreal;
+	real_server *e = NULL, *be = NULL;
+	element e1, e2 = NULL;
+	virtual_server *vs;
+#define STATE_RS_SORRY 1
+#define STATE_RS_REGULAR_FIRST 2
+#define STATE_RS_REGULAR_NEXT 3
+#define STATE_RS_END 4
+	int state;
+	int type, btype;
+
+        if ((result = snmp_oid_compare(name, *length, vp->name, vp->namelen)) < 0) {
+                memcpy(name, vp->name, sizeof(oid) * vp->namelen);
+                *length = vp->namelen;
+        }
+
+	*write_method = 0;
+	*var_len = sizeof(long);
+
+	if (LIST_ISEMPTY(check_data->vs))
+		return NULL;
+
+	/* We search the best match: equal if exact, the lower OID in
+	   the set of the OID strictly superior to the target
+	   otherwise. */
+        best[0] = best[1] = MAX_SUBID; /* Our best match */
+        target = &name[vp->namelen];   /* Our target match */
+        target_len = *length - vp->namelen;
+	for (e1 = LIST_HEAD(check_data->vs); e1; ELEMENT_NEXT(e1)) {
+		vs = ELEMENT_DATA(e1);
+		curvirtual++;
+		curreal = 0;
+		if (target_len && (curvirtual < target[0]))
+			continue; /* Optimization: cannot be part of our set */
+		if (be)
+			break; /* Optimization: cannot be the lower anymore */
+		state = STATE_RS_SORRY;
+		while (state != STATE_RS_END) {
+			switch (state) {
+			case STATE_RS_SORRY:
+				e = vs->s_svr;
+				type = state++;
+				break;
+			case STATE_RS_REGULAR_FIRST:
+				if (LIST_ISEMPTY(vs->rs)) {
+					e = NULL;
+					state = STATE_RS_END;
+					break;
+				}
+				e2 = LIST_HEAD(vs->rs);
+				e = ELEMENT_DATA(e2);
+				type = state++;
+				break;
+			case STATE_RS_REGULAR_NEXT:
+				type = state;
+				ELEMENT_NEXT(e2);
+				if (!e2) {
+					e = NULL;
+					state++;
+					break;
+				}
+				e = ELEMENT_DATA(e2);
+				break;
+			default:
+				/* Dunno? */
+				return NULL;
+			}
+			if (!e)
+				continue;
+			curreal++;
+			/* We build our current match */
+			current[0] = curvirtual;
+			current[1] = curreal;
+			/* And compare it to our target match */
+			if ((result = snmp_oid_compare(current, 2, target,
+						       target_len)) < 0)
+				continue;
+			if ((result == 0) && !exact)
+				continue;
+			if (result == 0) {
+				/* Got an exact match and asked for it */
+				be = e;
+				btype = type;
+				goto real_found;
+			}
+			if (snmp_oid_compare(current, 2, best, 2) < 0) {
+				/* This is our best match */
+				memcpy(best, current, sizeof(oid) * 2);
+				be = e;
+				btype = type;
+				goto real_be_found;
+			}
+		}
+	}
+	if (be == NULL)
+		/* No best match */
+		return NULL;
+	if (exact)
+		/* No exact match */
+		return NULL;
+ real_be_found:
+	/* Let's use our best match */
+        memcpy(target, best, sizeof(oid) * 2);
+        *length = vp->namelen + 2;
+ real_found:
+	switch (vp->magic) {
+	case CHECK_SNMP_RSTYPE:
+		long_ret = (btype == STATE_RS_SORRY)?2:1;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSADDRTYPE:
+		long_ret = (be->addr.ss_family == AF_INET6) ? 2:1;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSADDRESS:
+		RETURN_IP46ADDRESS(be);
+		break;
+	case CHECK_SNMP_RSPORT:
+		long_ret = htons(inet_sockaddrport(&be->addr));
+		return (u_char *)&long_ret;
+	case CHECK_SNMP_RSSTATUS:
+		if (btype == STATE_RS_SORRY) break;
+		long_ret = be->alive?1:2;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSWEIGHT:
+		if (btype == STATE_RS_SORRY) break;
+		long_ret = be->weight;
+		return (u_char*)&long_ret;
+#ifdef _KRNL_2_6_
+	case CHECK_SNMP_RSUPPERCONNECTIONLIMIT:
+		if (btype == STATE_RS_SORRY) break;
+		if (!be->u_threshold) break;
+		long_ret = be->u_threshold;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSLOWERCONNECTIONLIMIT:
+		if (btype == STATE_RS_SORRY) break;
+		if (!be->l_threshold) break;
+		long_ret = be->l_threshold;
+		return (u_char*)&long_ret;
+#endif
+	case CHECK_SNMP_RSACTIONWHENDOWN:
+		if (btype == STATE_RS_SORRY) break;
+		long_ret = be->inhibit?2:1;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSNOTIFYUP:
+		if (btype == STATE_RS_SORRY) break;
+		if (!be->notify_up) break;
+		*var_len = strlen(be->notify_up);
+		return (u_char*)be->notify_up;
+	case CHECK_SNMP_RSNOTIFYDOWN:
+		if (btype == STATE_RS_SORRY) break;
+		if (!be->notify_down) break;
+		*var_len = strlen(be->notify_down);
+		return (u_char*)be->notify_down;
+	case CHECK_SNMP_RSFAILEDCHECKS:
+		if (btype == STATE_RS_SORRY) break;
+		if (LIST_ISEMPTY(be->failed_checkers))
+			long_ret = 0;
+		else
+			long_ret = LIST_SIZE(be->failed_checkers);
+		return (u_char*)&long_ret;
+	default:
+		return NULL;
+	}
+	/* If we are here, we asked for a non existent data. Try the
+	   next one. */
+	if (!exact && (name[*length-1] < MAX_SUBID))
+		return check_snmp_realserver(vp, name, length,
+					     exact, var_len, write_method);
+        return NULL;
+}
+
+static oid check_oid[] = CHECK_OID;
+static struct variable8 check_vars[] = {
+	/* virtualServerGroupTable */
+	{CHECK_SNMP_VSGROUPNAME, ASN_OCTET_STR, RONLY,
+	 check_snmp_vsgroup, 3, {1, 1, 2}},
+	/* virtualServerGroupMemberTable */
+	{CHECK_SNMP_VSGROUPMEMBERTYPE, ASN_INTEGER, RONLY,
+	 check_snmp_vsgroupmember, 3, {2, 1, 2}},
+	{CHECK_SNMP_VSGROUPMEMBERFWMARK, ASN_UNSIGNED, RONLY,
+	 check_snmp_vsgroupmember, 3, {2, 1, 3}},
+	{CHECK_SNMP_VSGROUPMEMBERADDRTYPE, ASN_INTEGER, RONLY,
+	 check_snmp_vsgroupmember, 3, {2, 1, 4}},
+	{CHECK_SNMP_VSGROUPMEMBERADDRESS, ASN_OCTET_STR, RONLY,
+	 check_snmp_vsgroupmember, 3, {2, 1, 5}},
+	{CHECK_SNMP_VSGROUPMEMBERADDR1, ASN_OCTET_STR, RONLY,
+	 check_snmp_vsgroupmember, 3, {2, 1, 6}},
+	{CHECK_SNMP_VSGROUPMEMBERADDR2, ASN_OCTET_STR, RONLY,
+	 check_snmp_vsgroupmember, 3, {2, 1, 7}},
+	{CHECK_SNMP_VSGROUPMEMBERPORT, ASN_UNSIGNED, RONLY,
+	 check_snmp_vsgroupmember, 3, {2, 1, 8}},
+	/* virtualServerTable */
+	{CHECK_SNMP_VSTYPE, ASN_INTEGER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 2}},
+	{CHECK_SNMP_VSNAMEGROUP, ASN_OCTET_STR, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 3}},
+	{CHECK_SNMP_VSFWMARK, ASN_UNSIGNED, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 4}},
+	{CHECK_SNMP_VSADDRTYPE, ASN_INTEGER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 5}},
+	{CHECK_SNMP_VSADDRESS, ASN_OCTET_STR, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 6}},
+	{CHECK_SNMP_VSPORT, ASN_UNSIGNED, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 7}},
+	{CHECK_SNMP_VSPROTOCOL, ASN_INTEGER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 8}},
+	{CHECK_SNMP_VSLOADBALANCINGALGO, ASN_INTEGER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 9}},
+	{CHECK_SNMP_VSLOADBALANCINGKIND, ASN_INTEGER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 10}},
+	{CHECK_SNMP_VSSTATUS, ASN_INTEGER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 11}},
+	{CHECK_SNMP_VSVIRTUALHOST, ASN_OCTET_STR, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 12}},
+	{CHECK_SNMP_VSPERSIST, ASN_INTEGER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 13}},
+	{CHECK_SNMP_VSPERSISTTIMEOUT, ASN_UNSIGNED, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 14}},
+	{CHECK_SNMP_VSPERSISTGRANULARITY, ASN_OCTET_STR, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 15}},
+	{CHECK_SNMP_VSDELAYLOOP, ASN_UNSIGNED, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 16}},
+	{CHECK_SNMP_VSHASUSPEND, ASN_INTEGER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 17}},
+	{CHECK_SNMP_VSALPHA, ASN_INTEGER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 18}},
+	{CHECK_SNMP_VSOMEGA, ASN_INTEGER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 19}},
+	{CHECK_SNMP_VSREALTOTAL, ASN_UNSIGNED, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 20}},
+	{CHECK_SNMP_VSREALUP, ASN_UNSIGNED, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 21}},
+	{CHECK_SNMP_VSQUORUM, ASN_UNSIGNED, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 22}},
+	{CHECK_SNMP_VSQUORUMSTATUS, ASN_INTEGER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 23}},
+	{CHECK_SNMP_VSQUORUMUP, ASN_OCTET_STR, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 24}},
+	{CHECK_SNMP_VSQUORUMDOWN, ASN_OCTET_STR, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 25}},
+	{CHECK_SNMP_VSHYSTERESIS, ASN_UNSIGNED, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 26}},
+	/* realServerTable */
+	{CHECK_SNMP_RSTYPE, ASN_INTEGER, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 2}},
+	{CHECK_SNMP_RSADDRTYPE, ASN_INTEGER, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 3}},
+	{CHECK_SNMP_RSADDRESS, ASN_OCTET_STR, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 4}},
+	{CHECK_SNMP_RSPORT, ASN_UNSIGNED, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 5}},
+	{CHECK_SNMP_RSSTATUS, ASN_INTEGER, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 6}},
+	{CHECK_SNMP_RSWEIGHT, ASN_INTEGER, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 7}},
+#ifdef _KRNL_2_6_
+	{CHECK_SNMP_RSUPPERCONNECTIONLIMIT, ASN_UNSIGNED, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 8}},
+	{CHECK_SNMP_RSLOWERCONNECTIONLIMIT, ASN_UNSIGNED, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 9}},
+#endif
+	{CHECK_SNMP_RSACTIONWHENDOWN, ASN_INTEGER, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 10}},
+	{CHECK_SNMP_RSNOTIFYUP, ASN_OCTET_STR, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 11}},
+	{CHECK_SNMP_RSNOTIFYDOWN, ASN_OCTET_STR, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 12}},
+	{CHECK_SNMP_RSFAILEDCHECKS, ASN_UNSIGNED, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 13}},
+};
+
+void
+check_snmp_agent_init()
+{
+	snmp_agent_init(check_oid, OID_LENGTH(check_oid), "Healthchecker",
+			(struct variable *)check_vars,
+			sizeof(struct variable8),
+			sizeof(check_vars)/sizeof(struct variable8));
+}
+
+void
+check_snmp_agent_close()
+{
+	snmp_agent_close(check_oid, OID_LENGTH(check_oid), "Healthchecker");
+}
diff --git a/keepalived/include/check_snmp.h b/keepalived/include/check_snmp.h
new file mode 100644
index 0000000..9d52251
--- /dev/null
+++ b/keepalived/include/check_snmp.h
@@ -0,0 +1,36 @@
+/*
+ * Soft:        Vrrpd is an implementation of VRRPv2 as specified in rfc2338.
+ *              VRRP is a protocol which elect a master server on a LAN. If the
+ *              master fails, a backup server takes over.
+ *              The original implementation has been made by jerome etienne.
+ *
+ * Part:        check_snmp.c program include file.
+ *
+ * Version:     $Id$
+ *
+ * Author:      Vincent Bernat <bernat@luffy.cx>
+ *
+ *              This program is distributed in the hope that it will be useful, 
+ *              but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+ *              See the GNU General Public License for more details.
+ *
+ *              This program is free software; you can redistribute it and/or
+ *              modify it under the terms of the GNU General Public License
+ *              as published by the Free Software Foundation; either version
+ *              2 of the License, or (at your option) any later version.
+ *
+ * Copyright (C) 2001-2009 Alexandre Cassen, <acassen@freebox.fr>
+ */
+
+#ifndef _CHECK_SNMP_H
+#define _CHECK_SNMP_H
+
+#include "snmp.h"
+
+#define CHECK_OID {1, 3, 6, 1, 4, 1, 9586, 100, 5, 3}
+
+extern void check_snmp_agent_init(void);
+extern void check_snmp_agent_close(void);
+
+#endif
