commit 98ced5f00f0210d79d3dc2064abb1dbffd779500
Author: Vincent Bernat <bernat@luffy.cx>
Date:   Mon Aug 23 13:34:31 2010 +0200

    check: SNMP support for IPVS stats
    
    IPVS stats are exported with SNMP. A cache is used to avoid to query
    the kernel too much.

diff --git a/doc/KEEPALIVED-MIB b/doc/KEEPALIVED-MIB
index c53a54c..d0d45b4 100644
--- a/doc/KEEPALIVED-MIB
+++ b/doc/KEEPALIVED-MIB
@@ -1243,7 +1243,17 @@ VirtualServerEntry ::= SEQUENCE {
 	virtualServerQuorumStatus INTEGER,
 	virtualServerQuorumUp DisplayString,
 	virtualServerQuorumDown DisplayString,
-	virtualServerHysteresis Unsigned32
+	virtualServerHysteresis Unsigned32,
+	virtualServerStatsConns Gauge32,
+	virtualServerStatsInPkts Counter32,
+	virtualServerStatsOutPkts Counter32,
+	virtualServerStatsInBytes Counter64,
+	virtualServerStatsOutBytes Counter64,
+	virtualServerRateCps Gauge32,
+	virtualServerRateInPPS Gauge32,
+	virtualServerRateOutPPS Gauge32,
+	virtualServerRateInBPS Gauge32,
+	virtualServerRateOutBPS Gauge32
 }
 
 virtualServerIndex OBJECT-TYPE
@@ -1480,6 +1490,97 @@ virtualServerHysteresis OBJECT-TYPE
 	"Hysteresis with respect to quorum count."
     ::= { virtualServerEntry 26 }
 
+virtualServerStatsConns OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "connections"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Total number of connections scheduled for this virtual server."
+    ::= { virtualServerEntry 27 }
+
+virtualServerStatsInPkts OBJECT-TYPE
+    SYNTAX Counter32
+    UNITS "packets"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Total number of incoming packets for this virtual server."
+    ::= { virtualServerEntry 28 }
+
+virtualServerStatsOutPkts OBJECT-TYPE
+    SYNTAX Counter32
+    UNITS "packets"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Total number of outgoing packets for this virtual server."
+    ::= { virtualServerEntry 29 }
+
+virtualServerStatsInBytes OBJECT-TYPE
+    SYNTAX Counter64
+    UNITS "bytes"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Total number of incoming bytes for this virtual server."
+    ::= { virtualServerEntry 30 }
+
+virtualServerStatsOutBytes OBJECT-TYPE
+    SYNTAX Counter64
+    UNITS "bytes"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Total number of outgoing bytes for this virtual server."
+    ::= { virtualServerEntry 31 }
+
+virtualServerRateCps OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "connections/s"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current connection rate for this virtual server."
+    ::= { virtualServerEntry 32 }
+
+virtualServerRateInPPS OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "packets/s"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current in packet rate for this virtual server."
+    ::= { virtualServerEntry 33 }
+
+virtualServerRateOutPPS OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "packets/s"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current out packet rate for this virtual server."
+    ::= { virtualServerEntry 34 }
+
+virtualServerRateInBPS OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "bytes/s"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current incoming rate for this virtual server."
+    ::= { virtualServerEntry 35 }
+
+virtualServerRateOutBPS OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "bytes/s"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current outgoing rate for this virtual server."
+    ::= { virtualServerEntry 36 }
+
+
 -- real servers
 
 realServerTable OBJECT-TYPE
@@ -1512,7 +1613,20 @@ RealServerEntry ::= SEQUENCE {
 	realServerActionWhenDown INTEGER,
 	realServerNotifyUp DisplayString,
 	realServerNotifyDown DisplayString,
-	realServerFailedChecks Unsigned32
+	realServerFailedChecks Unsigned32,
+	realServerStatsConns Gauge32,
+	realServerStatsActiveConns Gauge32,
+	realServerStatsInactiveConns Gauge32,
+	realServerStatsPersistentConns Gauge32,
+	realServerStatsInPkts Counter32,
+	realServerStatsOutPkts Counter32,
+	realServerStatsInBytes Counter64,
+	realServerStatsOutBytes Counter64,
+	realServerRateCps Gauge32,
+	realServerRateInPPS Gauge32,
+	realServerRateOutPPS Gauge32,
+	realServerRateInBPS Gauge32,
+	realServerRateOutBPS Gauge32
 }
 
 realServerIndex OBJECT-TYPE
@@ -1620,6 +1734,124 @@ realServerFailedChecks OBJECT-TYPE
 	"How many failed checks for this real server."
     ::= { realServerEntry 13 }
 
+realServerStatsConns OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "connections"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Total number of connections scheduled for this real server."
+    ::= { realServerEntry 14 }
+
+realServerStatsActiveConns OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "connections"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current active connections for this real server."
+    ::= { realServerEntry 15 }
+
+realServerStatsInactiveConns OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "connections"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current inactive connections for this real server."
+    ::= { realServerEntry 16 }
+
+realServerStatsPersistentConns OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "connections"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current persistent connections for this real server."
+    ::= { realServerEntry 17 }
+
+realServerStatsInPkts OBJECT-TYPE
+    SYNTAX Counter32
+    UNITS "packets"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Total number of incoming packets for this real server."
+    ::= { realServerEntry 18 }
+
+realServerStatsOutPkts OBJECT-TYPE
+    SYNTAX Counter32
+    UNITS "packets"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Total number of outgoing packets for this real server."
+    ::= { realServerEntry 19 }
+
+realServerStatsInBytes OBJECT-TYPE
+    SYNTAX Counter64
+    UNITS "bytes"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Total number of incoming bytes for this real server."
+    ::= { realServerEntry 20 }
+
+realServerStatsOutBytes OBJECT-TYPE
+    SYNTAX Counter64
+    UNITS "bytes"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Total number of outgoing bytes for this real server."
+    ::= { realServerEntry 21 }
+
+realServerRateCps OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "connections/s"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current connection rate for this real server."
+    ::= { realServerEntry 22 }
+
+realServerRateInPPS OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "packets/s"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current in packet rate for this real server."
+    ::= { realServerEntry 23 }
+
+realServerRateOutPPS OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "packets/s"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current out packet rate for this real server."
+    ::= { realServerEntry 24 }
+
+realServerRateInBPS OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "bytes/s"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current incoming rate for this real server."
+    ::= { realServerEntry 25 }
+
+realServerRateOutBPS OBJECT-TYPE
+    SYNTAX Gauge32
+    UNITS "bytes/s"
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+	"Current outgoing rate for this real server."
+    ::= { realServerEntry 26 }
+
+
 -- ----------------------------------------------------------------------
 -- Conformance
 -- ----------------------------------------------------------------------
@@ -1811,7 +2043,17 @@ virtualServerGroup OBJECT-GROUP
 	virtualServerQuorumStatus,
 	virtualServerQuorumUp,
 	virtualServerQuorumDown,
-	virtualServerHysteresis
+	virtualServerHysteresis,
+	virtualServerStatsConns,
+	virtualServerStatsInPkts,
+	virtualServerStatsOutPkts,
+	virtualServerStatsInBytes,
+	virtualServerStatsOutBytes,
+	virtualServerRateCps,
+	virtualServerRateInPPS,
+	virtualServerRateOutPPS,
+	virtualServerRateInBPS,
+	virtualServerRateOutBPS
 	}
     STATUS current
     DESCRIPTION
@@ -1831,7 +2073,20 @@ realServerGroup OBJECT-GROUP
 	realServerActionWhenDown,
 	realServerNotifyUp,
 	realServerNotifyDown,
-	realServerFailedChecks
+	realServerFailedChecks,
+	realServerStatsConns,
+	realServerStatsActiveConns,
+	realServerStatsInactiveConns,
+	realServerStatsPersistentConns,
+	realServerStatsInPkts,
+	realServerStatsOutPkts,
+	realServerStatsInBytes,
+	realServerStatsOutBytes,
+	realServerRateCps,
+	realServerRateInPPS,
+	realServerRateOutPPS,
+	realServerRateInBPS,
+	realServerRateOutBPS
 	}
     STATUS current
     DESCRIPTION
diff --git a/keepalived/check/Makefile.in b/keepalived/check/Makefile.in
index c3d4a36..0c8da11 100644
--- a/keepalived/check/Makefile.in
+++ b/keepalived/check/Makefile.in
@@ -69,4 +69,4 @@ ipwrapper.o: ipwrapper.c ../include/ipwrapper.h ../../lib/memory.h \
 ipvswrapper.o: ipvswrapper.c ../include/ipvswrapper.h ../../lib/utils.h \
   ../../lib/memory.h
 check_snmp.o: check_snmp.c ../include/check_snmp.h ../include/check_data.h \
-  ../../lib/list.h
+  ../../lib/list.h ../include/ipvswrapper.h
diff --git a/keepalived/check/check_snmp.c b/keepalived/check/check_snmp.c
index a21b9bc..9cfc20d 100644
--- a/keepalived/check/check_snmp.c
+++ b/keepalived/check/check_snmp.c
@@ -25,6 +25,7 @@
 #include "check_snmp.h"
 #include "check_data.h"
 #include "list.h"
+#include "ipvswrapper.h"
 
 /* Magic */
 #define CHECK_SNMP_VSGROUPNAME 1
@@ -60,6 +61,16 @@
 #define CHECK_SNMP_VSHYSTERESIS 33
 #define CHECK_SNMP_VSREALTOTAL 34
 #define CHECK_SNMP_VSREALUP 35
+#define CHECK_SNMP_VSSTATSCONNS 61
+#define CHECK_SNMP_VSSTATSINPKTS 62
+#define CHECK_SNMP_VSSTATSOUTPKTS 63
+#define CHECK_SNMP_VSSTATSINBYTES 64
+#define CHECK_SNMP_VSSTATSOUTBYTES 65
+#define CHECK_SNMP_VSRATECPS 66
+#define CHECK_SNMP_VSRATEINPPS 67
+#define CHECK_SNMP_VSRATEOUTPPS 68
+#define CHECK_SNMP_VSRATEINBPS 69
+#define CHECK_SNMP_VSRATEOUTBPS 70
 #define CHECK_SNMP_RSTYPE 36
 #define CHECK_SNMP_RSADDRTYPE 37
 #define CHECK_SNMP_RSADDRESS 38
@@ -72,6 +83,19 @@
 #define CHECK_SNMP_RSNOTIFYUP 45
 #define CHECK_SNMP_RSNOTIFYDOWN 46
 #define CHECK_SNMP_RSFAILEDCHECKS 47
+#define CHECK_SNMP_RSSTATSCONNS 48
+#define CHECK_SNMP_RSSTATSACTIVECONNS 49
+#define CHECK_SNMP_RSSTATSINACTIVECONNS 50
+#define CHECK_SNMP_RSSTATSPERSISTENTCONNS 51
+#define CHECK_SNMP_RSSTATSINPKTS 52
+#define CHECK_SNMP_RSSTATSOUTPKTS 53
+#define CHECK_SNMP_RSSTATSINBYTES 54
+#define CHECK_SNMP_RSSTATSOUTBYTES 55
+#define CHECK_SNMP_RSRATECPS 56
+#define CHECK_SNMP_RSRATEINPPS 57
+#define CHECK_SNMP_RSRATEOUTPPS 58
+#define CHECK_SNMP_RSRATEINBPS 59
+#define CHECK_SNMP_RSRATEOUTBPS 60
 
 #define RETURN_IP46ADDRESS(entity)  do {				\
 		if (entity->addr.ss_family == AF_INET6) {		\
@@ -271,6 +295,9 @@ check_snmp_virtualserver(struct variable *vp, oid *name, size_t *length,
 			 int exact, size_t *var_len, WriteMethod **write_method)
 {
 	static unsigned long long_ret;
+#ifdef _KRNL_2_6_
+	static U64 counter64_ret;
+#endif
 	virtual_server *v;
 	element e;
 
@@ -428,6 +455,52 @@ check_snmp_virtualserver(struct variable *vp, oid *name, size_t *length,
 				if (((real_server *)ELEMENT_DATA(e))->alive)
 					long_ret++;
 		return (u_char*)&long_ret;
+#ifdef _KRNL_2_6_
+	case CHECK_SNMP_VSSTATSCONNS:
+		ipvs_update_stats(v);
+		long_ret = v->stats.conns;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSSTATSINPKTS:
+		ipvs_update_stats(v);
+		long_ret = v->stats.inpkts;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSSTATSOUTPKTS:
+		ipvs_update_stats(v);
+		long_ret = v->stats.outpkts;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSSTATSINBYTES:
+		ipvs_update_stats(v);
+		counter64_ret.low = v->stats.inbytes & 0xffffffff;
+		counter64_ret.high = v->stats.inbytes >> 32;
+		*var_len = sizeof(U64);
+		return (u_char*)&counter64_ret;
+	case CHECK_SNMP_VSSTATSOUTBYTES:
+		ipvs_update_stats(v);
+		counter64_ret.low = v->stats.outbytes & 0xffffffff;
+		counter64_ret.high = v->stats.outbytes >> 32;
+		*var_len = sizeof(U64);
+		return (u_char*)&counter64_ret;
+	case CHECK_SNMP_VSRATECPS:
+		ipvs_update_stats(v);
+		long_ret = v->stats.cps;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSRATEINPPS:
+		ipvs_update_stats(v);
+		long_ret = v->stats.inpps;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSRATEOUTPPS:
+		ipvs_update_stats(v);
+		long_ret = v->stats.outpps;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSRATEINBPS:
+		ipvs_update_stats(v);
+		long_ret = v->stats.inbps;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_VSRATEOUTBPS:
+		ipvs_update_stats(v);
+		long_ret = v->stats.outbps;
+		return (u_char*)&long_ret;
+#endif
 	default:
 		return NULL;
         }
@@ -442,12 +515,15 @@ check_snmp_realserver(struct variable *vp, oid *name, size_t *length,
 		      int exact, size_t *var_len, WriteMethod **write_method)
 {
 	static unsigned long long_ret;
+#ifdef _KRNL_2_6_
+	static U64 counter64_ret;
+#endif
         oid *target, current[2], best[2];
         int result, target_len;
 	int curvirtual = 0, curreal;
 	real_server *e = NULL, *be = NULL;
 	element e1, e2 = NULL;
-	virtual_server *vs;
+	virtual_server *vs, *bvs = NULL;
 #define STATE_RS_SORRY 1
 #define STATE_RS_REGULAR_FIRST 2
 #define STATE_RS_REGULAR_NEXT 3
@@ -526,6 +602,7 @@ check_snmp_realserver(struct variable *vp, oid *name, size_t *length,
 			if (result == 0) {
 				/* Got an exact match and asked for it */
 				be = e;
+				bvs = vs;
 				btype = type;
 				goto real_found;
 			}
@@ -533,6 +610,7 @@ check_snmp_realserver(struct variable *vp, oid *name, size_t *length,
 				/* This is our best match */
 				memcpy(best, current, sizeof(oid) * 2);
 				be = e;
+				bvs = vs;
 				btype = type;
 				goto real_be_found;
 			}
@@ -603,6 +681,64 @@ check_snmp_realserver(struct variable *vp, oid *name, size_t *length,
 		else
 			long_ret = LIST_SIZE(be->failed_checkers);
 		return (u_char*)&long_ret;
+#ifdef _KRNL_2_6_
+	case CHECK_SNMP_RSSTATSCONNS:
+		ipvs_update_stats(bvs);
+		long_ret = be->stats.conns;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSSTATSACTIVECONNS:
+		ipvs_update_stats(bvs);
+		long_ret = be->activeconns;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSSTATSINACTIVECONNS:
+		ipvs_update_stats(bvs);
+		long_ret = be->inactconns;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSSTATSPERSISTENTCONNS:
+		ipvs_update_stats(bvs);
+		long_ret = be->persistconns;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSSTATSINPKTS:
+		ipvs_update_stats(bvs);
+		long_ret = be->stats.inpkts;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSSTATSOUTPKTS:
+		ipvs_update_stats(bvs);
+		long_ret = be->stats.outpkts;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSSTATSINBYTES:
+		ipvs_update_stats(bvs);
+		counter64_ret.low = be->stats.inbytes & 0xffffffff;
+		counter64_ret.high = be->stats.inbytes >> 32;
+		*var_len = sizeof(U64);
+		return (u_char*)&counter64_ret;
+	case CHECK_SNMP_RSSTATSOUTBYTES:
+		ipvs_update_stats(bvs);
+		counter64_ret.low = be->stats.outbytes & 0xffffffff;
+		counter64_ret.high = be->stats.outbytes >> 32;
+		*var_len = sizeof(U64);
+		return (u_char*)&counter64_ret;
+	case CHECK_SNMP_RSRATECPS:
+		ipvs_update_stats(bvs);
+		long_ret = be->stats.cps;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSRATEINPPS:
+		ipvs_update_stats(bvs);
+		long_ret = be->stats.inpps;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSRATEOUTPPS:
+		ipvs_update_stats(bvs);
+		long_ret = be->stats.outpps;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSRATEINBPS:
+		ipvs_update_stats(bvs);
+		long_ret = be->stats.inbps;
+		return (u_char*)&long_ret;
+	case CHECK_SNMP_RSRATEOUTBPS:
+		ipvs_update_stats(bvs);
+		long_ret = be->stats.outbps;
+		return (u_char*)&long_ret;
+#endif
 	default:
 		return NULL;
 	}
@@ -685,6 +821,26 @@ static struct variable8 check_vars[] = {
 	 check_snmp_virtualserver, 3, {3, 1, 25}},
 	{CHECK_SNMP_VSHYSTERESIS, ASN_UNSIGNED, RONLY,
 	 check_snmp_virtualserver, 3, {3, 1, 26}},
+	{CHECK_SNMP_VSSTATSCONNS, ASN_GAUGE, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 27}},
+	{CHECK_SNMP_VSSTATSINPKTS, ASN_COUNTER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 28}},
+	{CHECK_SNMP_VSSTATSOUTPKTS, ASN_COUNTER, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 29}},
+	{CHECK_SNMP_VSSTATSINBYTES, ASN_COUNTER64, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 30}},
+	{CHECK_SNMP_VSSTATSOUTBYTES, ASN_COUNTER64, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 31}},
+	{CHECK_SNMP_VSRATECPS, ASN_GAUGE, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 32}},
+	{CHECK_SNMP_VSRATEINPPS, ASN_GAUGE, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 33}},
+	{CHECK_SNMP_VSRATEOUTPPS, ASN_GAUGE, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 34}},
+	{CHECK_SNMP_VSRATEINBPS, ASN_GAUGE, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 35}},
+	{CHECK_SNMP_VSRATEOUTBPS, ASN_GAUGE, RONLY,
+	 check_snmp_virtualserver, 3, {3, 1, 36}},
 	/* realServerTable */
 	{CHECK_SNMP_RSTYPE, ASN_INTEGER, RONLY,
 	 check_snmp_realserver, 3, {4, 1, 2}},
@@ -712,6 +868,34 @@ static struct variable8 check_vars[] = {
 	 check_snmp_realserver, 3, {4, 1, 12}},
 	{CHECK_SNMP_RSFAILEDCHECKS, ASN_UNSIGNED, RONLY,
 	 check_snmp_realserver, 3, {4, 1, 13}},
+#ifdef _KRNL_2_6_
+	{CHECK_SNMP_RSSTATSCONNS, ASN_GAUGE, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 14}},
+	{CHECK_SNMP_RSSTATSACTIVECONNS, ASN_GAUGE, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 15}},
+	{CHECK_SNMP_RSSTATSINACTIVECONNS, ASN_GAUGE, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 16}},
+	{CHECK_SNMP_RSSTATSPERSISTENTCONNS, ASN_GAUGE, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 17}},
+	{CHECK_SNMP_RSSTATSINPKTS, ASN_COUNTER, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 18}},
+	{CHECK_SNMP_RSSTATSOUTPKTS, ASN_COUNTER, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 19}},
+	{CHECK_SNMP_RSSTATSINBYTES, ASN_COUNTER64, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 20}},
+	{CHECK_SNMP_RSSTATSOUTBYTES, ASN_COUNTER64, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 21}},
+	{CHECK_SNMP_RSRATECPS, ASN_GAUGE, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 22}},
+	{CHECK_SNMP_RSRATEINPPS, ASN_GAUGE, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 23}},
+	{CHECK_SNMP_RSRATEOUTPPS, ASN_GAUGE, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 24}},
+	{CHECK_SNMP_RSRATEINBPS, ASN_GAUGE, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 25}},
+	{CHECK_SNMP_RSRATEOUTBPS, ASN_GAUGE, RONLY,
+	 check_snmp_realserver, 3, {4, 1, 26}},
+#endif
 };
 
 void
diff --git a/keepalived/check/ipvswrapper.c b/keepalived/check/ipvswrapper.c
index 6f49b19..1b9e298 100644
--- a/keepalived/check/ipvswrapper.c
+++ b/keepalived/check/ipvswrapper.c
@@ -677,6 +677,225 @@ ipvs_group_remove_entry(virtual_server *vs, virtual_server_group_entry *vsge)
 	return IPVS_SUCCESS;
 }
 
+#ifdef _WITH_SNMP_
+/* Update statistics for a given virtual server. This includes
+   statistics of real servers. The update is only done if we need
+   refreshing. */
+void
+ipvs_update_stats(virtual_server *vs)
+{
+	element e, ge = NULL;
+	real_server *rs;
+	virtual_server_group *vsg = NULL;
+	virtual_server_group_entry *vsg_entry = NULL;
+	uint32_t addr_ip = 0;
+	union nf_inet_addr nfaddr;
+	ipvs_service_entry_t * serv = NULL;
+	struct ip_vs_get_dests * dests = NULL;
+	int i;
+#define UPDATE_STATS_INIT 1
+#define UPDATE_STATS_VSG_IP 2
+#define UPDATE_STATS_VSG_FWMARK 4
+#define UPDATE_STATS_VSG_RANGE 6
+#define UPDATE_STATS_VSG_RANGE_IP 7
+#define UPDATE_STATS_END 99
+	int state = UPDATE_STATS_INIT;
+
+	if (time(NULL) - vs->lastupdated < STATS_REFRESH)
+		return;
+	vs->lastupdated = time(NULL);
+	/* Reset stats */
+	memset(&vs->stats, 0, sizeof(vs->stats));
+	if (vs->s_svr) {
+		memset(&vs->s_svr->stats, 0, sizeof(vs->s_svr->stats));
+		vs->s_svr->activeconns =
+			vs->s_svr->inactconns = vs->s_svr->persistconns = 0;
+	}
+	if (!LIST_ISEMPTY(vs->rs)) {
+		for (e = LIST_HEAD(vs->rs); e; ELEMENT_NEXT(e)) {
+			rs = ELEMENT_DATA(e);
+			memset(&rs->stats, 0, sizeof(rs->stats));
+			rs->activeconns = rs->inactconns = rs->persistconns = 0;
+		}
+	}
+	/* FSM: at each transition, we process "serv" if it is not NULL */
+	while (state != UPDATE_STATS_END) {
+		serv = NULL;
+		switch (state) {
+		case UPDATE_STATS_INIT:
+			/* We need to know the next state to reach */
+			if (vs->vsgname) {
+				if (!LIST_ISEMPTY(check_data->vs_group))
+					vsg = ipvs_get_group_by_name(vs->vsgname,
+								     check_data->vs_group);
+				else
+					vsg = NULL;
+				if (!vsg)
+					state = UPDATE_STATS_END;
+				else {
+					state = UPDATE_STATS_VSG_IP;
+					ge = NULL;
+				}
+				continue;
+			}
+			state = UPDATE_STATS_END;
+			if (vs->vfwmark) {
+				memset(&nfaddr, 0, sizeof(nfaddr));
+				serv = ipvs_get_service(vs->vfwmark,
+							AF_INET,
+							vs->service_type,
+							nfaddr, 0);
+				break;
+			}
+			memcpy(&nfaddr, (vs->addr.ss_family == AF_INET6)?
+			       (void*)(&((struct sockaddr_in6 *)&vs->addr)->sin6_addr):
+			       (void*)(&((struct sockaddr_in *)&vs->addr)->sin_addr),
+			       sizeof(nfaddr));
+			serv = ipvs_get_service(0,
+						vs->addr.ss_family,
+						vs->service_type,
+						nfaddr,
+						inet_sockaddrport(&vs->addr));
+			break;
+		case UPDATE_STATS_VSG_IP:
+			if (!ge)
+				ge = LIST_HEAD(vsg->addr_ip);
+			else
+				ELEMENT_NEXT(ge);
+			if (!ge) {
+				state = UPDATE_STATS_VSG_FWMARK;
+				continue;
+			}
+			vsg_entry = ELEMENT_DATA(ge);
+			memcpy(&nfaddr, (vsg_entry->addr.ss_family == AF_INET6)?
+			       (void*)(&((struct sockaddr_in6 *)&vsg_entry->addr)->sin6_addr):
+			       (void*)(&((struct sockaddr_in *)&vsg_entry->addr)->sin_addr),
+			       sizeof(nfaddr));
+			serv = ipvs_get_service(0,
+						vsg_entry->addr.ss_family,
+						vs->service_type,
+						nfaddr,
+						inet_sockaddrport(&vsg_entry->addr));
+			break;
+		case UPDATE_STATS_VSG_FWMARK:
+			if (!ge)
+				ge = LIST_HEAD(vsg->vfwmark);
+			else
+				ELEMENT_NEXT(ge);
+			if (!ge) {
+				state = UPDATE_STATS_VSG_RANGE;
+				continue;
+			}
+			vsg_entry = ELEMENT_DATA(ge);
+			memset(&nfaddr, 0, sizeof(nfaddr));
+			serv = ipvs_get_service(vsg_entry->vfwmark,
+						AF_INET,
+						vs->service_type,
+						nfaddr, 0);
+			break;
+		case UPDATE_STATS_VSG_RANGE:
+			if (!ge)
+				ge = LIST_HEAD(vsg->range);
+			else
+				ELEMENT_NEXT(ge);
+			if (!ge) {
+				state = UPDATE_STATS_END;
+				continue;
+			}
+			vsg_entry = ELEMENT_DATA(ge);
+			addr_ip = (vsg_entry->addr.ss_family == AF_INET6)?
+				((struct sockaddr_in6 *)&vsg_entry->addr)->sin6_addr.s6_addr32[3]:
+				((struct sockaddr_in *)&vsg_entry->addr)->sin_addr.s_addr;
+			state = UPDATE_STATS_VSG_RANGE_IP;
+			continue;
+		case UPDATE_STATS_VSG_RANGE_IP:
+			if (((addr_ip >> 24) & 0xFF) > vsg_entry->range) {
+				state = UPDATE_STATS_VSG_RANGE;
+				continue;
+			}
+			if (vsg_entry->addr.ss_family == AF_INET6) {
+				inet_sockaddrip6(&vsg_entry->addr, &nfaddr.in6);
+				nfaddr.in6.s6_addr32[3] = addr_ip;
+			} else {
+				nfaddr.in.s_addr = addr_ip;
+			}
+			serv = ipvs_get_service(0,
+						vsg_entry->addr.ss_family,
+						vs->service_type,
+						nfaddr,
+						inet_sockaddrport(&vsg_entry->addr));
+			addr_ip += 0x01000000;
+			break;
+		}
+		if (!serv) continue;
+		
+		/* Update virtual server stats */
+#define ADD_TO_VSSTATS(X) vs->stats.X += serv->stats.X;
+		ADD_TO_VSSTATS(conns);
+		ADD_TO_VSSTATS(inpkts);
+		ADD_TO_VSSTATS(outpkts);
+		ADD_TO_VSSTATS(inbytes);
+		ADD_TO_VSSTATS(outbytes);
+		ADD_TO_VSSTATS(cps);
+		ADD_TO_VSSTATS(inpps);
+		ADD_TO_VSSTATS(outpps);
+		ADD_TO_VSSTATS(inbps);
+		ADD_TO_VSSTATS(outbps);
+
+		/* Get real servers */
+		dests = ipvs_get_dests(serv);
+		if (!dests) {
+			FREE(serv);
+			return;
+		}
+		for (i = 0; i < dests->num_dests; i++) {
+			rs = NULL;
+
+#define VSD_EQUAL(entity) (((entity)->addr.ss_family == AF_INET &&	\
+			    dests->entrytable[i].af == AF_INET &&	\
+			    inaddr_equal(AF_INET,			\
+					 &dests->entrytable[i].addr,	\
+					 &((struct sockaddr_in *)&(entity)->addr)->sin_addr) && \
+			    dests->entrytable[i].port == ((struct sockaddr_in *)&(entity)->addr)->sin_port) || \
+			   ((entity)->addr.ss_family == AF_INET6 &&	\
+			    dests->entrytable[i].af == AF_INET6 &&	\
+			    inaddr_equal(AF_INET6, \
+					 &dests->entrytable[i].addr,	\
+					 &((struct sockaddr_in6 *)&(entity)->addr)->sin6_addr) && \
+			    dests->entrytable[i].port == ((struct sockaddr_in6 *)&(entity)->addr)->sin6_port))
+			/* Is it the sorry server? */
+			if (vs->s_svr && VSD_EQUAL(vs->s_svr))
+				rs = vs->s_svr;
+			else if (!LIST_ISEMPTY(vs->rs))
+				/* Search for a match in the list of real servers */
+				for (e = LIST_HEAD(vs->rs); e; ELEMENT_NEXT(e)) {
+					rs = ELEMENT_DATA(e);
+					if (VSD_EQUAL(rs))
+						break;
+				}
+			if (rs) {
+#define ADD_TO_RSSTATS(X) rs->X += dests->entrytable[i].X
+				ADD_TO_RSSTATS(activeconns);
+				ADD_TO_RSSTATS(inactconns);
+				ADD_TO_RSSTATS(persistconns);
+				ADD_TO_RSSTATS(stats.conns);
+				ADD_TO_RSSTATS(stats.inpkts);
+				ADD_TO_RSSTATS(stats.outpkts);
+				ADD_TO_RSSTATS(stats.inbytes);
+				ADD_TO_RSSTATS(stats.outbytes);
+				ADD_TO_RSSTATS(stats.cps);
+				ADD_TO_RSSTATS(stats.inpps);
+				ADD_TO_RSSTATS(stats.outpps);
+				ADD_TO_RSSTATS(stats.inbps);
+				ADD_TO_RSSTATS(stats.outbps);
+			}
+		}
+		FREE(dests);
+		FREE(serv);
+	}
+}
+
+#endif /* _WITH_SNMP_ */
 #endif
 
 /*
diff --git a/keepalived/include/check_data.h b/keepalived/include/check_data.h
index e3ff458..0852e4e 100644
--- a/keepalived/include/check_data.h
+++ b/keepalived/include/check_data.h
@@ -84,6 +84,14 @@ typedef struct _real_server {
 	int alive;
 	list failed_checkers;	/* List of failed checkers */
 	int set;		/* in the IPVS table */
+
+#if defined(_WITH_SNMP_) && defined(_KRNL_2_6_)
+	/* Statistics */
+	u_int32_t activeconns;	/* active connections */
+	u_int32_t inactconns;	/* inactive connections */
+	u_int32_t persistconns;	/* persistent connections */
+	struct ip_vs_stats_user stats;
+#endif
 } real_server;
 
 /* Virtual Server group definition */
@@ -126,6 +134,12 @@ typedef struct _virtual_server {
 
 	long unsigned hysteresis;	/* up/down events "lag" WRT quorum. */
 	unsigned quorum_state;		/* Reflects result of the last transition done. */
+
+#if defined(_WITH_SNMP_) && defined(_KRNL_2_6_)
+	/* Statistics */
+	time_t lastupdated;
+	struct ip_vs_stats_user stats;
+#endif
 } virtual_server;
 
 /* Configuration data root */
diff --git a/keepalived/include/ipvswrapper.h b/keepalived/include/ipvswrapper.h
index 498732c..646a992 100644
--- a/keepalived/include/ipvswrapper.h
+++ b/keepalived/include/ipvswrapper.h
@@ -98,4 +98,10 @@ extern int ipvs_syncd_cmd(int, char *, int, int);
 extern void ipvs_syncd_master(char *, int);
 extern void ipvs_syncd_backup(char *, int);
 
+#ifdef _KRNL_2_6_
+/* Refresh statistics at most every 5 seconds */
+#define STATS_REFRESH 5
+extern void ipvs_update_stats(virtual_server * vs);
+#endif
+
 #endif
diff --git a/keepalived/libipvs-2.6/libipvs.h b/keepalived/libipvs-2.6/libipvs.h
index bd5852e..08543ec 100644
--- a/keepalived/libipvs-2.6/libipvs.h
+++ b/keepalived/libipvs-2.6/libipvs.h
@@ -95,6 +95,9 @@ extern int ipvs_cmp_services(ipvs_service_entry_t *s1,
 extern void ipvs_sort_services(struct ip_vs_get_services *s,
 			       ipvs_service_cmp_t f);
 
+/* get one IPVS service */
+extern ipvs_service_entry_t *ipvs_get_service(__u32, __u16, __u16, union nf_inet_addr, __u16);
+
 /* get the destination array of the specified service */
 extern struct ip_vs_get_dests *ipvs_get_dests(ipvs_service_entry_t *svc);
 
