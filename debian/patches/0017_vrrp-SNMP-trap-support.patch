commit b799458be24d51d74ff6fb0d1658e04eee1f3016
Author: Vincent Bernat <bernat@luffy.cx>
Date:   Mon Aug 23 11:57:31 2010 +0200

    vrrp: SNMP trap support.
    
    Traps are sent when:
     - instance state changes
     - sync group state changes

diff --git a/doc/KEEPALIVED-MIB b/doc/KEEPALIVED-MIB
index 7c8e33b..bb2458f 100644
--- a/doc/KEEPALIVED-MIB
+++ b/doc/KEEPALIVED-MIB
@@ -1051,6 +1051,34 @@ vrrpScriptFall OBJECT-TYPE
         "How many times the script should fail before KO."
     ::= { vrrpScriptEntry 8 }
 
+-- Traps
+
+vrrpTrap OBJECT IDENTIFIER ::= { vrrp 9 }
+vrrpTraps OBJECT IDENTIFIER ::= { vrrpTrap 0 } -- Reverse-mappable
+vrrpTrapControl OBJECT IDENTIFIER ::= { vrrpTrap 1 }
+
+vrrpSyncGroupStateChange NOTIFICATION-TYPE
+    OBJECTS {
+    	vrrpSyncGroupName,
+	vrrpSyncGroupState
+    }
+    STATUS current
+    DESCRIPTION
+	"This trap signifies that the state of the whole vrrp sync
+	group changed."
+    ::= { vrrpTraps 1 }
+
+vrrpInstanceStateChange NOTIFICATION-TYPE
+    OBJECTS {
+    	vrrpInstanceName,
+	vrrpInstanceState,
+	vrrpInstanceInitialState
+    }
+    STATUS current
+    DESCRIPTION
+	"This trap signifies that the state of a vrrp instance changed."
+    ::= { vrrpTraps 2 }
+
 -- ----------------------------------------------------------------------
 -- Healthchecker part
 -- ----------------------------------------------------------------------
@@ -1885,7 +1913,8 @@ vrrpCompliances MODULE-COMPLIANCE
     MANDATORY-GROUPS {
 	vrrpScriptGroup,
 	vrrpSyncGroup,
-	vrrpInstanceGroup
+	vrrpInstanceGroup,
+	vrrpTrapsGroup
     }
     ::= { compliances 2 }
 
@@ -1918,6 +1947,8 @@ globalGroup OBJECT-GROUP
 	"Conformance group for global data."
     ::= { groups 1 }
 
+vrrpGroups OBJECT IDENTIFIER ::= { groups 2 }
+
 vrrpSyncGroup OBJECT-GROUP
     OBJECTS {
 	vrrpSyncGroupName,
@@ -1933,7 +1964,7 @@ vrrpSyncGroup OBJECT-GROUP
     STATUS current
     DESCRIPTION
 	"Conformance group for synchronisation groups."
-    ::= { groups 2 }
+    ::= { vrrpGroups 1 }
 
 vrrpInstanceGroup OBJECT-GROUP
     OBJECTS {
@@ -1993,7 +2024,7 @@ vrrpInstanceGroup OBJECT-GROUP
     STATUS current
     DESCRIPTION
 	"Conformance group for VRRP instances."
-    ::= { groups 3 }
+    ::= { vrrpGroups 2 }
 
 vrrpScriptGroup OBJECT-GROUP
     OBJECTS {
@@ -2008,7 +2039,17 @@ vrrpScriptGroup OBJECT-GROUP
     STATUS current
     DESCRIPTION
 	"Conformance group for VRRP scripts."
-    ::= { groups 4 }
+    ::= { vrrpGroups 3 }
+
+vrrpTrapsGroup NOTIFICATION-GROUP
+    NOTIFICATIONS {
+    	vrrpSyncGroupStateChange,
+    	vrrpInstanceStateChange
+	}
+    STATUS current
+    DESCRIPTION
+	"Conformance group for VRRP traps."
+    ::= { vrrpGroups 4 }
 
 virtualServerGroupGroup OBJECT-GROUP
     OBJECTS {
diff --git a/keepalived/include/vrrp_snmp.h b/keepalived/include/vrrp_snmp.h
index e763221..bf6990e 100644
--- a/keepalived/include/vrrp_snmp.h
+++ b/keepalived/include/vrrp_snmp.h
@@ -28,9 +28,11 @@
 
 #include "snmp.h"
 
-#define VRRP_OID {1, 3, 6, 1, 4, 1, 9586, 100, 5, 2}
+#define VRRP_OID KEEPALIVED_OID, 2
 
 extern void vrrp_snmp_agent_init(void);
 extern void vrrp_snmp_agent_close(void);
+extern void vrrp_snmp_instance_trap(vrrp_rt *);
+extern void vrrp_snmp_group_trap(vrrp_sgroup *);
 
 #endif
diff --git a/keepalived/vrrp/Makefile.in b/keepalived/vrrp/Makefile.in
index aba9c4b..0c60802 100644
--- a/keepalived/vrrp/Makefile.in
+++ b/keepalived/vrrp/Makefile.in
@@ -49,16 +49,16 @@ vrrp_parser.o: vrrp_parser.c ../include/vrrp_parser.h \
 vrrp.o: vrrp.c ../include/vrrp.h ../include/vrrp_scheduler.h \
   ../include/vrrp_notify.h ../include/ipvswrapper.h ../../lib/memory.h \
   ../../lib/list.h ../include/vrrp_data.h ../include/vrrp_sync.h ../include/vrrp_index.h \
-  ../include/vrrp_arp.h ../../lib/utils.h
+  ../include/vrrp_arp.h ../../lib/utils.h ../include/snmp.h ../include/vrrp_snmp.h
 vrrp_notify.o: vrrp_notify.c ../include/vrrp_notify.h ../../lib/memory.h \
   ../../lib/notify.h
 vrrp_scheduler.o: vrrp_scheduler.c ../include/vrrp_scheduler.h \
   ../include/vrrp_ipsecah.h ../include/vrrp_if.h ../include/vrrp.h \
   ../include/vrrp_sync.h ../include/vrrp_notify.h ../include/ipvswrapper.h \
   ../../lib/memory.h ../../lib/list.h ../include/vrrp_data.h ../include/vrrp_index.h \
-  ../include/smtp.h ../../lib/notify.h
+  ../include/smtp.h ../../lib/notify.h ../include/snmp.h ../include/vrrp_snmp.h
 vrrp_sync.o: vrrp_sync.c ../include/vrrp_sync.h ../include/vrrp_if.h \
-  ../include/vrrp_notify.h ../include/vrrp_data.h
+  ../include/vrrp_notify.h ../include/vrrp_data.h  ../include/snmp.h ../include/vrrp_snmp.h
 vrrp_index.o: vrrp_index.c ../include/vrrp_index.h ../include/vrrp.h \
   ../include/vrrp_data.h ../../lib/memory.h
 vrrp_netlink.o: vrrp_netlink.c ../include/vrrp_netlink.h ../include/check_api.h \
@@ -79,4 +79,5 @@ vrrp_ndisc.o: vrrp_ndisc.c ../include/vrrp_ndisc.h ../include/vrrp_ipaddress.h \
   ../../lib/utils.h ../../lib/memory.h
 vrrp_snmp.o: vrrp_snmp.c ../include/vrrp_snmp.h ../include/vrrp_track.h \
   ../include/vrrp_data.h ../include/vrrp_ipaddress.h ../include/vrrp_iproute.h \
-  ../include/vrrp.h ../../lib/vector.h ../../lib/list.h ../include/snmp.h 
+  ../include/vrrp.h ../../lib/vector.h ../../lib/list.h ../include/snmp.h \
+  ../include/global_data.h ../../lib/logger.h
diff --git a/keepalived/vrrp/vrrp.c b/keepalived/vrrp/vrrp.c
index 158ed3e..9de80e3 100644
--- a/keepalived/vrrp/vrrp.c
+++ b/keepalived/vrrp/vrrp.c
@@ -35,6 +35,9 @@
 #include "vrrp_data.h"
 #include "vrrp_sync.h"
 #include "vrrp_index.h"
+#ifdef _WITH_SNMP_
+#include "vrrp_snmp.h"
+#endif
 #include "memory.h"
 #include "list.h"
 #include "logger.h"
@@ -725,7 +728,9 @@ vrrp_state_become_master(vrrp_rt * vrrp)
 
 	/* Check if notify is needed */
 	notify_instance_exec(vrrp, VRRP_STATE_MAST);
-
+#ifdef _WITH_SNMP_
+	vrrp_snmp_instance_trap(vrrp);
+#endif
 #ifdef _HAVE_IPVS_SYNCD_
 	/* Check if sync daemon handling is needed */
 	if (vrrp->lvs_syncd_if)
@@ -795,12 +800,18 @@ vrrp_state_leave_master(vrrp_rt * vrrp)
 		vrrp_restore_interface(vrrp, 0);
 		vrrp->state = vrrp->wantstate;
 		notify_instance_exec(vrrp, VRRP_STATE_BACK);
+#ifdef _WITH_SNMP_
+		vrrp_snmp_instance_trap(vrrp);
+#endif
 		break;
 	case VRRP_STATE_GOTO_FAULT:
 		log_message(LOG_INFO, "VRRP_Instance(%s) Entering FAULT STATE", vrrp->iname);
 		vrrp_restore_interface(vrrp, 0);
 		vrrp->state = VRRP_STATE_FAULT;
 		notify_instance_exec(vrrp, VRRP_STATE_FAULT);
+#ifdef _WITH_SNMP_
+		vrrp_snmp_instance_trap(vrrp);
+#endif
 		break;
 	}
 
diff --git a/keepalived/vrrp/vrrp_scheduler.c b/keepalived/vrrp/vrrp_scheduler.c
index e5bfcf0..53d514d 100644
--- a/keepalived/vrrp/vrrp_scheduler.c
+++ b/keepalived/vrrp/vrrp_scheduler.c
@@ -37,6 +37,9 @@
 #include "main.h"
 #include "smtp.h"
 #include "signals.h"
+#ifdef _WITH_SNMP_
+#include "vrrp_snmp.h"
+#endif
 
 /* VRRP FSM (Finite State Machine) design.
  *
@@ -255,6 +258,9 @@ vrrp_init_state(list l)
 			vrrp->state = VRRP_STATE_BACK;
 			vrrp_smtp_notifier(vrrp);
 			notify_instance_exec(vrrp, VRRP_STATE_BACK);
+#ifdef _WITH_SNMP_
+			vrrp_snmp_instance_trap(vrrp);
+#endif
 
 			/* Init group if needed  */
 			if ((vgroup = vrrp->sync)) {
@@ -262,6 +268,9 @@ vrrp_init_state(list l)
 					vgroup->state = VRRP_STATE_BACK;
 					vrrp_sync_smtp_notifier(vgroup);
 					notify_group_exec(vgroup, VRRP_STATE_BACK);
+#ifdef _WITH_SNMP_
+					vrrp_snmp_group_trap(vgroup);
+#endif
 				}
 			}
 		}
@@ -641,6 +650,9 @@ vrrp_leave_fault(vrrp_rt * vrrp, char *buffer, int len)
 				vrrp->state = VRRP_STATE_BACK;
 				vrrp_smtp_notifier(vrrp);
 				notify_instance_exec(vrrp, VRRP_STATE_BACK);
+#ifdef _WITH_SNMP_
+				vrrp_snmp_instance_trap(vrrp);
+#endif
 			}
 		} else {
 			log_message(LOG_INFO, "VRRP_Instance(%s) Entering BACKUP STATE",
@@ -648,6 +660,9 @@ vrrp_leave_fault(vrrp_rt * vrrp, char *buffer, int len)
 			vrrp->state = VRRP_STATE_BACK;
 			vrrp_smtp_notifier(vrrp);
 			notify_instance_exec(vrrp, VRRP_STATE_BACK);
+#ifdef _WITH_SNMP_
+			vrrp_snmp_instance_trap(vrrp);
+#endif
 		}
 	}
 }
@@ -664,6 +679,9 @@ vrrp_goto_master(vrrp_rt * vrrp)
 		vrrp->state = VRRP_STATE_FAULT;
 		vrrp->ms_down_timer = 3 * vrrp->adver_int + VRRP_TIMER_SKEW(vrrp);
 		notify_instance_exec(vrrp, VRRP_STATE_FAULT);
+#ifdef _WITH_SNMP_
+		vrrp_snmp_instance_trap(vrrp);
+#endif
 	} else {
 		/* If becoming MASTER in IPSEC AH AUTH, we reset the anti-replay */
 		if (vrrp->ipsecah_counter->cycle) {
@@ -802,6 +820,9 @@ vrrp_fault(vrrp_rt * vrrp)
 		if (vrrp->init_state == VRRP_STATE_BACK) {
 			vrrp->state = VRRP_STATE_BACK;
 			notify_instance_exec(vrrp, VRRP_STATE_BACK);
+#ifdef _WITH_SNMP_
+			vrrp_snmp_instance_trap(vrrp);
+#endif
 		} else {
 			vrrp_goto_master(vrrp);
 		}
diff --git a/keepalived/vrrp/vrrp_snmp.c b/keepalived/vrrp/vrrp_snmp.c
index 40343a0..9a01720 100644
--- a/keepalived/vrrp/vrrp_snmp.c
+++ b/keepalived/vrrp/vrrp_snmp.c
@@ -31,6 +31,8 @@
 #include "config.h"
 #include "vector.h"
 #include "list.h"
+#include "logger.h"
+#include "global_data.h"
 
 /* Magic */
 #define VRRP_SNMP_SCRIPT_NAME 3
@@ -865,7 +867,7 @@ vrrp_snmp_trackedscript(struct variable *vp, oid *name, size_t *length,
 	return NULL;
 }
 
-static oid vrrp_oid[] = VRRP_OID;
+static oid vrrp_oid[] = {VRRP_OID};
 static struct variable8 vrrp_vars[] = {
 	/* vrrpSyncGroupTable */
 	{VRRP_SNMP_SYNCGROUP_NAME, ASN_OCTET_STR, RONLY,
@@ -1020,3 +1022,111 @@ vrrp_snmp_agent_close()
 {
 	snmp_agent_close(vrrp_oid, OID_LENGTH(vrrp_oid), "VRRP");
 }
+
+void
+vrrp_snmp_instance_trap(vrrp_rt *vrrp)
+{
+	/* OID of the notification */
+	oid notification_oid[] = { VRRP_OID, 9, 0, 2 };
+	size_t notification_oid_len = OID_LENGTH(notification_oid);
+	/* OID for snmpTrapOID.0 */
+	oid objid_snmptrap[] = { SNMPTRAP_OID };
+	size_t objid_snmptrap_len = OID_LENGTH(objid_snmptrap);
+
+	/* Other OID */
+	oid name_oid[] = { VRRP_OID, 3, 1, 2 };
+	size_t name_oid_len = OID_LENGTH(name_oid);
+	oid state_oid[] = { VRRP_OID, 3, 1, 4 };
+	size_t state_oid_len = OID_LENGTH(state_oid);
+	oid initialstate_oid[] = { VRRP_OID, 3, 1, 5};
+	size_t initialstate_oid_len = OID_LENGTH(initialstate_oid);
+
+	netsnmp_variable_list *notification_vars = NULL;
+
+        static unsigned long state;
+	static unsigned long istate;
+
+	if (!data->enable_traps) return;
+
+	/* snmpTrapOID */
+	snmp_varlist_add_variable(&notification_vars,
+				  objid_snmptrap, objid_snmptrap_len,
+				  ASN_OBJECT_ID,
+				  (u_char *) notification_oid,
+				  notification_oid_len * sizeof(oid));
+	/* vrrpInstanceName */
+	snmp_varlist_add_variable(&notification_vars,
+				  name_oid, name_oid_len,
+				  ASN_OCTET_STR,
+				  (u_char *)vrrp->iname,
+                                  strlen(vrrp->iname));
+	/* vrrpInstanceState */
+	state = vrrp_snmp_state(vrrp->state);
+	snmp_varlist_add_variable(&notification_vars,
+				  state_oid, state_oid_len,
+				  ASN_INTEGER,
+				  (u_char *)&state,
+				  sizeof(state));
+	/* vrrpInstanceInitialState */
+	istate = vrrp_snmp_state(vrrp->init_state);
+	snmp_varlist_add_variable(&notification_vars,
+				  initialstate_oid, initialstate_oid_len,
+				  ASN_INTEGER,
+				  (u_char *)&istate,
+				  sizeof(istate));
+
+	log_message(LOG_INFO,
+		    "VRRP_Instance(%s): Sending SNMP notification",
+		    vrrp->iname);
+	send_v2trap(notification_vars);
+	snmp_free_varbind(notification_vars);
+}
+
+void
+vrrp_snmp_group_trap(vrrp_sgroup *group)
+{
+	/* OID of the notification */
+	oid notification_oid[] = { VRRP_OID, 9, 0, 1 };
+	size_t notification_oid_len = OID_LENGTH(notification_oid);
+	/* OID for snmpTrapOID.0 */
+	oid objid_snmptrap[] = { SNMPTRAP_OID };
+	size_t objid_snmptrap_len = OID_LENGTH(objid_snmptrap);
+
+	/* Other OID */
+	oid name_oid[] = { VRRP_OID, 3, 1, 2 };
+	size_t name_oid_len = OID_LENGTH(name_oid);
+	oid state_oid[] = { VRRP_OID, 3, 1, 4 };
+	size_t state_oid_len = OID_LENGTH(state_oid);
+
+	netsnmp_variable_list *notification_vars = NULL;
+
+        static unsigned long state;
+
+	if (!data->enable_traps) return;
+
+	/* snmpTrapOID */
+	snmp_varlist_add_variable(&notification_vars,
+				  objid_snmptrap, objid_snmptrap_len,
+				  ASN_OBJECT_ID,
+				  (u_char *) notification_oid,
+				  notification_oid_len * sizeof(oid));
+	/* vrrpInstanceName */
+	snmp_varlist_add_variable(&notification_vars,
+				  name_oid, name_oid_len,
+				  ASN_OCTET_STR,
+				  (u_char *)group->gname,
+                                  strlen(group->gname));
+	/* vrrpInstanceState */
+	state = vrrp_snmp_state(group->state);
+	snmp_varlist_add_variable(&notification_vars,
+				  state_oid, state_oid_len,
+				  ASN_INTEGER,
+				  (u_char *)&state,
+				  sizeof(state));
+
+	log_message(LOG_INFO,
+		    "VRRP_Group(%s): Sending SNMP notification",
+		    group->gname);
+	send_v2trap(notification_vars);
+	snmp_free_varbind(notification_vars);
+}
diff --git a/keepalived/vrrp/vrrp_sync.c b/keepalived/vrrp/vrrp_sync.c
index d57d404..77263f5 100644
--- a/keepalived/vrrp/vrrp_sync.c
+++ b/keepalived/vrrp/vrrp_sync.c
@@ -24,6 +24,9 @@
 #include "vrrp_if.h"
 #include "vrrp_notify.h"
 #include "vrrp_data.h"
+#ifdef _WITH_SNMP_
+#include "vrrp_snmp.h"
+#endif
 #include "logger.h"
 #include "smtp.h"
 
@@ -191,6 +194,9 @@ vrrp_sync_backup(vrrp_rt * vrrp)
 	vgroup->state = VRRP_STATE_BACK;
 	vrrp_sync_smtp_notifier(vgroup);
 	notify_group_exec(vgroup, VRRP_STATE_BACK);
+#ifdef _WITH_SNMP_
+	vrrp_snmp_group_trap(vgroup);
+#endif
 }
 
 void
@@ -221,6 +227,9 @@ vrrp_sync_master(vrrp_rt * vrrp)
 	vgroup->state = VRRP_STATE_MAST;
 	vrrp_sync_smtp_notifier(vgroup);
 	notify_group_exec(vgroup, VRRP_STATE_MAST);
+#ifdef _WITH_SNMP_
+	vrrp_snmp_group_trap(vgroup);
+#endif
 }
 
 void
@@ -256,4 +265,7 @@ vrrp_sync_fault(vrrp_rt * vrrp)
 	}
 	vgroup->state = VRRP_STATE_FAULT;
 	notify_group_exec(vgroup, VRRP_STATE_FAULT);
+#ifdef _WITH_SNMP_
+	vrrp_snmp_group_trap(vgroup);
+#endif
 }
